[
	{
		"code": "io.sarl.lang.validation.IssueCodes.redundant_interface_implementation",
		"message": "Duplicate implemented feature '*interface-name*'",
		"cause": "An interface, named *interface-name*, is implemented by a class. But, the interface with name *interface-name* is already implemented by the same class. It is not allowed by the SARL compiler to implement two time the same interface into a single class",
		"solution": "Remove the redundant *interface-name*",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.redundant_interface_implementation",
		"message": "The feature '*interface-name*' is already implemented by the super-type '*type-name*'",
		"cause": "This error may occur in two cases.\nFirst, the interface named *interface-name* is implemented by the current class. But, it is also implemented by one of the super classes, named *type-name*, or it is a super-interface, named *type-name*, of another implemented interface by the class. The current specification of the interface implementation becomes redundant and unnecessary.\nSecond, the interface named *interface-name* is extended by the current interface. But, it is also defined as a super-interface for the super-interface named *type-name*. The current specification of the interface implementation becomes redundant and unnecessary",
		"solution": "Remove the redundant *interface-name*",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.discouraged_boolean_expression",
		"message": "Unexpected assertion due to its positive test result",
		"cause": "It is discouraged to have the constant `true` as condition of the `assert` statement. Indeed, a condition that is always evaluated to true for an assertion test makes this test void and time consuming for nothing",
		"solution": "Remove the `assert` statement",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.discouraged_boolean_expression",
		"message": "Discouraged boolean value. The guard is always true",
		"cause": "It is discouraged to have the constant `true` as condition of an behavior unit's guard. Indeed, a condition that is always evaluated to true makes the test void and time consuming for nothing",
		"solution": "Remove the guard of the behavior unit",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.discouraged_capacity_definition",
		"message": "Discouraged capacity definition. A capacity without actions defined inside is not useful since it cannot be called by an agent or a behavior",
		"cause": "Message is explicit. There no sense to create a capacity without action according to the SARL metamodel",
		"solution": "Define an action within the capacity; or delete the capacity",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.discouraged_function_name",
		"message": "Invalid action name '*n*'. You must not give to an action a name with reserved characters",
		"cause": "Several names are discouraged to be used by the SARL compiler. One reason may be because the name is expected to be used as part of the language in future releases. Or, the name is amgiguous. For example, the name \"self\" is discouraged by the SARL compiler",
		"solution": "Change the function name",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.unreachable_behavior_unit",
		"message": "Dead code. The guard is always false",
		"cause": "The guard that is specified for a behavior unit is evaluated by the compiler to be always false. In this case, the code of the behavior unit has absolutely no change to be executed. It may denote a problem is the design of the entity in which the behavior unit is defined, e.g. an agent",
		"solution": "Change the guard condition; or remove the entier behavior unit",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_capacity_type",
		"message": "Invalid type: '*type-name*'. Only capacities can be used after the keyword 'uses'",
		"cause": "The keyword `uses` enables to uses and import capacities within the scope of the entity (agent, behavior, etc.) in which the `uses` is specified. This error is generated when the type named *type-name* that is specified after an `uses` is not a sub-type of `Capacity`, i.e. it is not a capacity type",
		"solution": "Remove the *type-name* after the keyword `uses`; or replace *type-name* by the name of an appropriate capacity",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_firing_event_type",
		"message": "Invalid type: '*type-name*'. Only events can be used after the keyword 'fires'",
		"cause": "The keyword `fires` specifies the events that could be fired by a function. This error is generated when the type named *type-name* that is specified after an `fires` is not a sub-type of `Capacity`, i.e. it is not a capacity type",
		"solution": "Remove the *type-name* after the keyword `fires`; or replace *type-name* by the name of an appropriate capacity",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_implemented_type",
		"message": "Invalid implemented type: '*type-name*'. Only subtypes of '*expected-name*' are allowed for '*element-name*'",
		"cause": "This error message is generated when the provided type named *type-name* is invalid when it is specified for an `implements` statement; because it is not a sub-type of *expected-name* strictly (i.e., not *expected-name* itself). When it is used for the definition of *element-name*, an implemented type must fullfil the previous typing constraint",
		"solution": "Remove *type-name*; or replace it by the appropriate name of a sub-type of *expected-name*",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_implemented_type",
		"message": "Invalid implemented type: '*type-name*'. Only the type '*expected-name*' and one of its subtypes are allowed for '*element-name*'",
		"cause": "This error message is generated when the provided type named *type-name* is invalid when it is specified for an `implements` statement; because it is neither equals to *expected-name* nor a sub-type of *expected-name*. When it is used for the definition of *element-name*, an implemented type must fullfil the previous typing constraint",
		"solution": "Remove *type-name*; or replace it by the appropriate name of a sub-type of *expected-name*",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.unused_agent_capacity",
		"message": "Unnecessary use of the capacity '*capacity-name*' because it is implemented by the current skill",
		"cause": "This issue is generated when the capacity named *capacity-name* is specified after a `uses` keyword; and it is at the same time an implemented capacity by the skill in which the `uses` statement is specified. The `uses` specification is redundant, because the functions that are defined into the capacity *capacity-name* are already accessible due to their local implementation",
		"solution": "Remove *capacity-name* from the `uses` statement",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.unused_agent_capacity",
		"message": "The capacity '*capacity-name*' is not used",
		"cause": "This issue is generated when *capacity-name* is specified after a `uses` statement, but none of the capacity's functions is invoked from the current entity (agent, etc.)",
		"solution": "Remove *capacity-name* from the `uses` statement",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.redundant_capacity_use",
		"message": "Redundant use of the capacity '*capacity-name*'",
		"cause": "The capacity named *capacity-name* is specified more than one time after a `uses` statement. It is not necessary to specify a capacity name multiple name, since the compiler has already activated the access to the capacity's functions with the first occurrence of *capacity-name*",
		"solution": "Remove the redundant *capacity-name* from the `uses` statement",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_extended_type",
		"message": "Supertype must be a subtype of '*type-name*'",
		"cause": "This error message is generated when the provided type after the `extends` statement is invalid; because it is not a sub-type of *type-name* strictly (i.e., not *type-name* itself)",
		"solution": "Remove the type after `extends`; or replace it by the appropriate name of a sub-type of *type-name*",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_extended_type",
		"message": "Supertype must be of type '*type-name*'",
		"cause": "This error message is generated when the provided type after the `extends` statement is invalid; because it is neither equals to *type-name* nor a sub-type of *type-name*",
		"solution": "Remove the type after `extends`; or replace it by the appropriate name of a sub-type of *type-name*",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_nested_definition",
		"message": "Nested agents are not allowed inside *enclosing-type*",
		"cause": "It is not allowed by the SARL language's syntax to define an `agent` inside another type declaration, named *enclosing-type*",
		"solution": "Move the agent definition outside the enclosing type",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_nested_definition",
		"message": "Nested behaviors are not allowed inside *enclosing-type*",
		"cause": "It is not allowed by the SARL language's syntax to define a `behavior` inside another type declaration, named *enclosing-type*",
		"solution": "Move the behavior definition outside the enclosing type",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_nested_definition",
		"message": "Nested capacities are not allowed inside *enclosing-type*",
		"cause": "It is not allowed by the SARL language's syntax to define a `capacity` inside another type declaration, named *enclosing-type*",
		"solution": "Move the capacity definition outside the enclosing type",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_nested_definition",
		"message": "Nested skills are not allowed inside *enclosing-type*",
		"cause": "It is not allowed by the SARL language's syntax to define a `skill` inside another type declaration, named *enclosing-type*",
		"solution": "Move the capacity definition outside the enclosing type",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_nested_definition",
		"message": "Nested events are not allowed inside *enclosing-type*",
		"cause": "It is not allowed by the SARL language's syntax to define an `event` inside another type declaration, named *enclosing-type*",
		"solution": "Move the event definition outside the enclosing type",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.return_type_specification_is_recommended",
		"message": "Expecting the return type *type-name*. It is recommended to write the return type, even if it is inferred from the overridden function",
		"cause": "SARL compiler is able to infer the type of the return values of a function according to the inherited prototype for the same function. In this case, it is not mandatory to specify explitly the return type into the overiding prototypes. Nevertheless, it is considered as a good practice to specify the return type. This issue message informs the developer of this recommendation",
		"solution": "Add the return type into the overriding function prototype",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.sarl_lib_not_on_classpath",
		"message": "SARL library not found on the classpath. Error code: *code*; Resources on classpath are:\n*classpath*\nDeclared fields in SARLVersion class:\n*sarl-verison*",
		"cause": "The SARL library is not on the *classpath*. The cause of the error is specified by the given *code* that is one of NO_SARL_VERSION_CLASS (SARL version class not found), NO_SARL_VERSION_DECLARED_TYPE (SARL version class is not a Xtext declared type), NO_SARL_VERSION_FIELD (SARL version field not found), NO_SARL_VERSION_VALUE (SARL version value not found), or INVALID_SARL_VERSION_BYTECODE (the byte code (the class) of `SARLVersion` does not contains the expected field)",
		"solution": "Reconfigure your project to have the SARL libraries into the classpath",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_sarl_lib_on_classpath",
		"message": "Incompatible SARL library on the classpath. Actual: *actual-version*. Expected: *expected-version*",
		"cause": "The SARL library found on the classpath (*actual-version*) is not compatible with the compiler's version (*expected-version*)",
		"solution": "Reconfigure your project to have the SARL libraries with *expected-version* into the classpath",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.use_reserved_sarl_annotation",
		"message": "Discouraged use of reserved annotation. @*name* is an annotation that is reserved for the compiler usage",
		"cause": "SARL core library defines a collection of SARL annotations that are dedicated to the internal usage of the SARL compiler. They are supposed to never be in the SARL code directly. This issue message is generated when one of these SARL annotations is explicitly specified into the code",
		"solution": "Remove the SARL annotation from your code",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.programmatic_issue_annotation",
		"message": "*any-message*",
		"cause": "It is possible to generate issue messages when a feature is used or invoked from the SARL code. The specification of the issue message is done by using one of the annotations `@ErrorOnCall`, `@WarningOnCall` or `@InfoOnCall` that takes an message (*any-message*). This annotation is attached to the feature for which a call must generate the issue",
		"level": "c/error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_occurrence_readonly_use",
		"message": "Invalid use of the unmodifiable feature 'occurrence'. You cannot use 'occurrence' at the left-side of an assignment operator",
		"cause": "The keyword `occurrence` represents the current instance of the just-received event within a behavior unit. It is assumed within the SARL operational semantics that `occurrence` instance is an unmodifiable event in order to ensure consistency between the different behavior units that handle the `occurrence`. This error message is generated when you try to assign a value to an `occurrence`, that is forbidden",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_occurrence_readonly_use",
		"message": "Invalid use of the unmodifiable feature 'occurrence'. You cannot use 'occurrence' as the operand of a postfix operator because it causes a side effect",
		"cause": "The keyword `occurrence` represents the current instance of the just-received event within a behavior unit. It is assumed within the SARL operational semantics that `occurrence` instance is an unmodifiable event in order to ensure consistency between the different behavior units that handle the `occurrence`. This error message is generated when you try to change the value of `occurrence` with a postfix operator, e.g., `++`, that is forbidden",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.discouraged_occurrence_readonly_use",
		"message": "Possible invalid usage of 'occurrence'. A impure function is detected into the sequence of calls on 'occurrence'. Because a impure function has a possible side effect and side effect is not allowed on 'occurrence', it may cause an unexpected or invalid running behavior. You have to ensure by yourself that the usage of 'occurrence' is valid",
		"cause": "The keyword `occurrence` represents the current instance of the just-received event within a behavior unit. It is assumed within the SARL operational semantics that `occurrence` instance is an unmodifiable event in order to ensure consistency between the different behavior units that handle the `occurrence`. This message is generated one component of the `occurrence` event is used in a way that its value may be changed. The SARL compiler is not sure that a change is applied to the `occurrence` from the code analysis. It notifies you that you have to double check the usage of `occurrence` and validate that no side-effect exist on it. If the used component of `occurrence` is of immutable type, then this issue does not exist",
		"solution": "Rewrite your code to avoid the use of the impure function(s)",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.discouraged_occurrence_readonly_use",
		"message": "Possible invalid usage of 'occurrence'. The value of the feature 'occurrence' or one of its component seems to be copied within a local variable. Because side effect is not allowed on 'occurrence', it may cause an unexpected or invalid running behavior. You have to ensure by yourself that the usage of 'occurrence' is valid",
		"cause": "Message is clear",
		"solution": "Rewrite your code to avoid the use of the impure function(s)",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.discouraged_occurrence_readonly_use",
		"message": "Possible invalid usage of 'occurrence'. The value of the feature 'occurrence' or one of its component is used as an argument of a function. This function is not marked as a pure function, i.e. without side effect. Because side effect is not allowed on 'occurrence', it may cause an unexpected or invalid running behavior. You have to ensure by yourself that the usage of 'occurrence' is valid",
		"cause": "Message is clear",
		"solution": "Mark with `@Pure` the function that takes `occurrence` as argument; or Change your code to avoid the passing of `occurrence` to the concerned function",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.manual_inline_definition",
		"message": "Discouraged manual definition of an inline expression. Inline expression definition is reserved for advanced usage",
		"cause": "The `@Inline` annotation enables the SARL compiler to replace the call to the annotated function by the expression specified inside the annotation. It may be useful for making faster the generated Java code. However, the expression inside `@Inline` must be written in valid Java and following strict inlining rules. That's why, the explicit usage of `@Inline` is not recommended, except to advanced SARL developers",
		"solution": "Remove the `@Inline` annotation",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.discouraged_loop_breaking_keyword_use",
		"message": "Discouraged use of the break keyword inside a basic loop",
		"cause": "`break` statement enables to stop the execution of a loop step by continuing the execution after the loop itself. However, according the algothimic best practices, it is not recommended to use the `break` statement for stopping a loop. It may denote a poor algorithmic analysis",
		"solution": "Rewrite the loop code",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.discouraged_loop_breaking_keyword_use",
		"message": "Discouraged use of the continue keyword inside a basic loop",
		"cause": "`continue` statement enables to stop the execution of a loop step by continuing the execution at the next loop step. However, according the algothimic best practices, it is not recommended to use the `continue` statement for stopping a loop. It may denote a poor algorithmic analysis",
		"solution": "Rewrite the loop code",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_use_of_loop_breaking_keyword",
		"message": "Invalid use of the break keyword. It could only be used inside loops",
		"cause": "`break` statement enables to stop the execution of a loop step by continuing the execution after the loop itself. The `break` keyword is not supposed to be used outside a loop expression",
		"solution": "Remove the `break` statement",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_use_of_loop_breaking_keyword",
		"message": "Invalid use of the continue keyword. It could only be used inside loops",
		"cause": "`continue` statement enables to stop the execution of a loop step by continuing the execution at the next loop step. The `continue` keyword is not supposed to be used outside a loop expression",
		"solution": "Remove the `break` statement",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_extra_language_generation",
		"message": "*any-message*",
		"cause": "Extra-language generator is an extension module of the SARL compiler. It has the role to generate source code in a specific programming language, e.g., Python, that is not supported by the core generator of the SARL compiler, i.e., Java. When the extra-language generator encounters an issue (error, warning or information), it is notified with is issue code",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.unexpected_formal_parameter",
		"message": "Unexpected formal parameter to a static constructor",
		"cause": "A static constructor could be defined for initializing the static fields of a type. It is forbidden to define a formal parameter for a static constructor because their is no way to assign values to the corresponding arguments",
		"solution": "Remove the formal parameter(s) from static constructor",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.unexpected_exception_throw",
		"message": "Unexpected exception to a static constructor",
		"cause": "A static constructor could be defined for initializing the static fields of a type. It is forbidden to define a list of thrown exceptions for a static constructor because they cannot be catched",
		"solution": "Remove the `thrown` definition",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.missing_body",
		"message": "Missing code for a static constructor",
		"cause": "A static constructor could be defined for initializing the static fields of a type. It is forbidden to define a static constructor without a block of code",
		"solution": "Add a block of code to the static constructor",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_default_skill_annotation",
		"message": "Invalid annotation value. *skill-name* is not an implementation of *capacity-name*",
		"cause": "The `@DefaultSkill` annotation enables to specify programmatically the skill that may be used by default by an agent for implementing a capacity. The parameter named *skill-name* of the `@DefaultSill` must be a skill that implements the capacity *capacity-name*",
		"solution": "Remove the `@DefaultSkill`; or replace *skill-name* by an appropriate skill type name",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.invalid_default_skill_annotation",
		"message": "Invalid annotation value. It must be a type literal to a skill",
		"cause": "The `@DefaultSkill` annotation enables to specify programmatically the skill that may be used by default by an agent for implementing a capacity. The parameter of the annotation must be the type name of a skill",
		"solution": "Remove the `@DefaultSkill`; or replace *skill-name* by an appropriate skill type name",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.potential_field_synchronization_problem",
		"message": "The field *field-name* should be synchronized for avoiding value inconsistency due to parallel execution",
		"cause": "Within the SARL operational semantic, a SARL program is executed in parallel, i.e., all the behavior units and the individual agent tasks are executed in different threaded tasks. Due to this run-time principle, the access to the fields within the scope of an agent (agent, behavior, skill) must be considered carefully. This issue code is generated by the compiler in order to notify the SARL developer that a synchronization issue may occur on the field named *field-name*. In this case, the SARL compiler cannot infer a default synchronization policy, it is recommended to the SARL developer to implement explicitly a synchronization method",
		"solution": "Put the field access into a synchronization block",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.internal_error",
		"message": "*any-message*",
		"cause": "This error is generated when the SARL compiler has encountered an internal error",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.potential_inefficient_value_conversion",
		"message": "Potential inefficient value conversion. This operation is based on a call to the function '*func-name*', which may cause inefficient code execution",
		"cause": "When the `as` casting operator is used, SARL compiler infers the best method to convert the origin expression to a target type. The possible methods are:\n1) Direct low-level cast that is natively supported by the virtual machine.\n2) If the target type is a primitive type, find a function named \"*type-name*Value()\" within the current scope.\n3) If the target type is not a primitive type, find a function named \"to*type-name*()\" within the current scope.\nIf none of these cases fits, an cast error is generated. However, the cases 2 and 3 means that a cast operator will be supported by a call to a function. Depending on the implementation of the called function, the call may be inefficient at run-time",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.potential_inefficient_value_conversion",
		"message": "Potential inefficient value conversion. This operation is based on a call to the function '*func-name*', which generates a value of type '*origin-type*' that is converted on-the-fly to '*target-type*'",
		"cause": "When the `as` casting operator is used, SARL compiler infers the best method to convert the origin expression of type *origin-type* to the target *target-type*. The possible methods are:\n1) Direct low-level cast that is natively supported by the virtual machine.\n2) If *target-type* is a primitive type, find a function named \"*target-type*Value()\" within the current scope.\n3) If *target-type* is not a primitive type, find a function named \"to*target-type*()\" within the current scope.\nIf none of these cases fits, an cast error is generated. However, the cases 2 and 3 means that a cast operator will be supported by a call to *func-name* function. Depending on the implementation of *func-name*, the call may be inefficient at run-time",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.java_doc_linking",
		"message": "javaDoc: *type-ref* cannot be resolved to a type",
		"cause": "A hyperlink to a type into the Javadoc points to an unknown type named *type-ref*",
		"solution": "Change the *type-name*",
		"level": "d/org.eclipse.jdt.core.compiler.problem.invalidJavadoc/ignore"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.wrong_annotation_target",
		"message": "The annotation @*name* is disallowed for this location",
		"cause": "An annotation is defined in order to be attached to a specific type of element (type, field, method, etc.). This error is generated when an annotation with the given *name* is attached to a wrong type of element",
		"soluton": "Remove the annotation; or replace it by an appropriate annotation",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.wrong_annotation_target",
		"message": "Unexpected annotation to a static constructor",
		"cause": "A static constructor cannot have an annotation attached to it. This issue message is generated when a static constructor is annotated",
		"soluton": "Remove the annotation",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.multiple_annotations_used",
		"message": "Multiple annotations of non-repeatable type @*name*. Only annotation types marked @Repeatable can be used multiple times at one target",
		"cause": "By definition, an annotation could be attached multiple times to an element only if it is declared as repeatable with the `@Repeatable` annotation. This issue message is generated when the annotation with the given *name* is attached multiple times to an element, and the annotation `@Repeatable` is not attached to the declaration of the annotation with the given *name*",
		"soluton": "Remove redundant annotations",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.case_function_without_params",
		"message": "A dispatch method must at least have one parameter declared",
		"cause": "A dispatch function is a function to which multiple blocks of code are attached to. Each block of code is invoked according to a specific type of the first formal parameter of the dispatch function. This error message is generated when a dispatch function has no parameter delcared",
		"solution": "Add a formal parameter",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.case_function_with_type_params",
		"message": "A dispatch method must not declare any type parameters",
		"cause": "A dispatch function is a function to which multiple blocks of code are attached to. Each block of code is invoked according to a specific type of the first formal parameter of the dispatch function. This error message is generated when a generic type parameter is defined in the dispatch function prototype; that is forbidden",
		"solution": "Remove generic type declaration",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.case_func_name_starts_with_underscore",
		"message": "A dispatch method's name must not start with an underscore",
		"cause": "A dispatch function is a function to which multiple blocks of code are attached to. Each block of code is invoked according to a specific type of the first formal parameter of the dispatch function. Internally, each block is attached to an hidden function with a name started with an underscore `_` character. In order to avoid any conflict with the internal functions, it is forbidden to start the name of a dispatch function with an underscore character",
		"solution": "Rename your dispatch function",
		"level": "error"
	},
	{
		"code": "dispatch_functions_with_different_visibility",
		"message": "All local dispatch methods must have the same visibility",
		"cause": "A dispatch function is a function to which multiple blocks of code are attached to. Each block of code is invoked according to a specific type of the first formal parameter of the dispatch function. It is forbidden to define the different prototypes for a single dispatch function with different visibilities",
		"solution": "Use the same function visility for all the prototypes of the same dispatch function",
		"level": "error"
	},
	{
		"code": "dispatch_functions_mixed_static_and_non_static",
		"message": "Static and non-static dispatch methods can not be mixed",
		"cause": "A dispatch function is a function to which multiple blocks of code are attached to. Each block of code is invoked according to a specific type of the first formal parameter of the dispatch function. It is forbidden to mix static and not static prototypes for a single dispatch function",
		"solution": "Make static or non-static all the prototypes of the same dispatch function",
		"level": "error"
	},
	{
		"code": "dispatch_functions_static_expected",
		"message": "The dispatch method must be static because the dispatch methods in the superclass are static",
		"cause": "A dispatch function is a function to which multiple blocks of code are attached to. Each block of code is invoked according to a specific type of the first formal parameter of the dispatch function. This error message is generated when a dispatch function into the current type is not defined as static function; while the dispatch functions defined into the super-type are defined as static. You cannot mix static and non-static definitions",
		"solution": "Add `static` modifier to the prototype of the local dispatch function",
		"level": "error"
	},
	{
		"code": "dispatch_functions_non_static_expected",
		"message": "The dispatch method must not be static because the dispatch methods in the superclass are not static",
		"cause": "A dispatch function is a function to which multiple blocks of code are attached to. Each block of code is invoked according to a specific type of the first formal parameter of the dispatch function. This error message is generated when a dispatch function into the current type is defined as static function; while the dispatch functions defined into the super-type are not defined as static. You cannot mix static and non-static definitions",
		"solution": "Remove `static` modifier from the prototype of the local dispatch function",
		"level": "error"
	},
	{
		"code": "dispatch_functions_must_not_be_abstract",
		"message": "The dispatch method *fct-name* in type *type-name* must not be abstract",
		"cause": "A dispatch function is a function to which multiple blocks of code are attached to. Each block of code is invoked according to a specific type of the first formal parameter of the dispatch function. Because of this definition, it is forbidden to define, implictly or explicitly, a dispatch function as abstract",
		"solution": "Add block of code for the dispatch function",
		"level": "error"
	},
	{
		"code": "dispatch_functions_may_not_widen_inherited_signature",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.single_case_function",
		"message": "Single dispatch method",
		"cause": "A dispatch function is a function to which multiple blocks of code are attached to. Each block of code is invoked according to a specific type of the first formal parameter of the dispatch function. If you define a single block of code for a dispatch function, dispatch function syntax is not the best choice for performance reason. Indeed defining the same function as a not-dispatching function has the same operational effects, and faster",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.dispatch_plain_function_name_clash",
		"message": "Non-dispatch method has same name and number of parameters as dispatch method",
		"cause": "A conflict is detected between the name of a dispatch function and the name of not-dispatching function. In this case, the SARL compiler is still able to invoke both functions. Nevertheless, it introduces an ambiguity for the caller of the functions that may have a call to the wrong function. This issue message notifies you that you have to take care of this situation, and ensure that the calls to functions are targeted the right function code",
		"solution": "Rename the non-dispatch function; or the dispatch function",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.dispatch_plain_function_name_clash",
		"message": "Dispatch method has same name and number of parameters as non-dispatch method",
		"cause": "A conflict is detected between the name of a dispatch function and the name of not-dispatching function. In this case, the SARL compiler is still able to invoke both functions. Nevertheless, it introduces an ambiguity for the caller of the functions that may have a call to the wrong function. This issue message notifies you that you have to take care of this situation, and ensure that the calls to functions are targeted the right function code",
		"solution": "Rename the dispatch function; or the non-dispatch function",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.dispatch_functions_different_primitive_args",
		"message": "Dispatch methods have arguments with different primitive types",
		"cause": "A dispatch function is a function to which multiple blocks of code are attached to. Each block of code is invoked according to a specific type of the first formal parameter of the dispatch function. You could define more formal parameters than the mandatory one. This issue message is generated when the formal parameters at the same position into the prototypes of a dispatch function have not the same primitive type. It may cause issues, e.g., a loose of information due the automatic boxing of the parameter values",
		"solution": "Change the primitive types to have the same in all the prototypes",
		"level": "c/warning"
	},
	{
		"code": "create_functions_must_not_be_abstract",
		"message": "The 'create'-method *func-name* in type *type-name* must not be abstract",
		"cause": "Creation method is inspired from the [factory-method design pattern](https://en.wikipedia.org/wiki/Factory_method_pattern). It is forbidden to define this type of method without code",
		"solution": "Add source code to the creation method",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.wrong_package",
		"message": "The declared package '*actual-name*' does not match the expected package '*expected-name*'",
		"cause": "SARL enables to create groups of types that are named packages in order to increase the modularity of your software. The different types are written into SARL files that are located in folders. Usually the name of the package reflects the structure of the underlying folders, i.e., the sequence of folders' names corresponds to the sequence of package name's atoms. In the Java language this mapping is mandatory. In SARL language, this mapping is optional, but considered as a good practice. The SARL compiler notifies you that the *expected-name* may be preferred to the *actual-name*",
		"solution": "Replace *actual-name* by *expected-name*",
		"level": "warning"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.wrong_package",
		"message": "Unexpecting package definition",
		"cause": "SARL enables to create groups of types that are named packages in order to increase the modularity of your software. The different types are written into SARL files that are located in folders. Usually the name of the package reflects the structure of the underlying folders, i.e., the sequence of folders' names corresponds to the sequence of package name's atoms. In the Java language this mapping is mandatory. In SARL language, this mapping is optional, but considered as a good practice. The SARL compiler notifies you that no name is expected for the package",
		"solution": "Remove the package definition",
		"level": "warning"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.wrong_file",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.class_expected",
		"message": "Superclass must be a class",
		"cause": "According to the syntax of SARL, a class extends another class. This error message indicates to you that the type after `extends` is not a class",
		"solution": "Remove the `extends` statement; or replace the invalid type by the appropriate class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.class_expected",
		"message": "Invalid supertype. Expecting a class",
		"cause": "According to the syntax of SARL, a type (class, agent, skill, etc.) extends another type. This error message indicates to you that the type after `extends` is not a type implemented with a Java class, when it is expected to have one",
		"solution": "Remove the `extends` statement; or replace the invalid type by the appropriate class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.interface_expected",
		"message": "Implemented interface must be an interface",
		"cause": "According to the syntax of SARL, a class implements interfaces. This error message indicates to you that one type after `implements` is not an interface",
		"solution": "Remove the `extends` statement; or replace the invalid type by the appropriate class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.interface_expected",
		"message": "Extended interface must be an interface",
		"cause": "According to the syntax of SARL, an interface extends another interface. This error message indicates to you that the type after `extends` is not an interface",
		"solution": "Remove the `extends` statement; or replace the invalid type by the appropriate class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.interface_expected",
		"message": "Invalid supertype. Expecting an interface",
		"cause": "According to the syntax of SARL, a type (interface, capacity, etc.) extends another type. This error message indicates to you that the type after `extends` is not a type implemented with a Java interface, when it is expected to have one",
		"solution": "Remove the `extends` statement; or replace the invalid type by the appropriate interface type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.duplicate_method",
		"message": "Duplicate method *func-prototype* in type *type-name*",
		"cause": "It is forbidden to define two times a function with the same prototype/erasure. This error message is generated when two functions has the same prototype inside the current type declaration",
		"solution": "Rename one of the functions; or change the erasure of one of them",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.duplicate_method",
		"message": "The method *func-prototype* has the same erasure *func-erasure* as another method in type *type-name*",
		"cause": "It is forbidden to define two times a function with the same prototype/erasure. This error message is generated when two functions has the same prototype inside the current type declaration",
		"solution": "Rename one of the functions; or change the erasure of one of them",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.duplicate_method",
		"message": "The instance method *func-prototype* cannot override the static method *static-prototype* of type *type-name*",
		"cause": "It is forbidden to define a function with the same prototype/erasure as an inherited static function without adding the `static`modifier to the inheriting function prototype",
		"solution": "Add `static` modifier to the function prototype",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.duplicate_method",
		"message": "Name clash: The method *func-prototype* of type *type-name* has the same erasure as *other-prototype*  of type *other-type* but does not override it",
		"cause": "It is forbidden to define a non-static function without the same prototype/erasure as an inherited non-static static function",
		"solution": "Change the *func-prototype* to be compatible with *other-prototype*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.duplicate_method",
		"message": "Duplicate dispatch methods. Primitives cannot overload their wrapper types in dispatch methods",
		"cause": "It is forbidden to define a dispatch function without the same prototype/erasure as an inherited dispatch function",
		"solution": "Change the prototype of the dispatch function in order to be compatible with the prototype of the inherited dispatch function",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.duplicate_field",
		"message": "Duplicate field *name*",
		"cause": "It is forbidden to define multiple fields with the same name into the same type. This error message is generated when two fields have the given *name*",
		"solution": "Rename one of the two fields",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.duplicate_field",
		"message": "Duplicate extension with same type",
		"cause": "[Extension on fields](./general/Extension.md) is supported by SARL syntax. This error message is generated when two extensions have the same name. It is forbidden because they generate two hidden fields with the same name",
		"solution": "Rename one of the extensions",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.conflicting_default_methods",
		"message": "The type *type-name* inherits multiple implementations of the method *func-prototype* from *first-type* and *second-type*",
		"cause": "This error message is generated when the current type with name *type-name* inherited a block of code for the function with the signature *func-prototype*, either from the super-type named *first-type* and the one named *second-type*. It is impossible for the SARL compiler to determine which one of the two blocks of code to be associated to *type-name*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.conflicting_default_methods",
		"message": "The non-abstract method *first-prototype* inherited from *first-type* conflicts with the method *second-prototype* inherited from *second-type*",
		"cause": "This error message is generated when the current type inherited from two functions from types *first-type* and *second-type*, and there is a conflict between the signatures of these functions",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.missing_abstract",
		"message": "The abstract method *func-name* in type *type-name* can only be defined by an abstract class",
		"cause": "An abstract method/function is a function without block of code. The keyword `abstract` could be missed on a function only if the enclosing type is defined as abstract too",
		"solution": "Add the modifier `abstract` into the prototype of *func-name*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.missing_abstract",
		"message": "The method *func-name* in type *type-name* should be declared abstract",
		"cause": "An abstract method/function is a function without block of code. The keyword `abstract` could be missed but it is a good practice to specify it explicitle. This warning is generated to notify you that an `abstract` is missed and may be added to the function prototype",
		"solution": "Add the modifier `abstract` into the prototype of *func-name*",
		"level": "warning"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.missing_abstract_in_anonymous",
		"message": "The abstract method *func-prototype* in type *type-name* can only be defined by an abstract class",
		"cause": "It is forbidden to define an abstract function into an anonymous class",
		"solution": "Add block of code for the function with prototype *func-prototype*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.missing_override",
		"message": "The method *func-prototype* of type *type-name* must use override keyword since it actually overrides a supertype method",
		"cause": "A function with the prototype *func-prototype* is defined into the type *type-name*. The same function prototype is defined into and inherited from a super-type. A good practice is to replace the `def` keyword by `override` in order to make explicit the fact that the function into *type-name* overrides another function",
		"level": "c/ignore"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.obsolete_override",
		"message": "The method *func-prototype* of type *type-name* shadows the method *other-prototype* of type *other-type*, but does not override it",
		"cause": "You have used the keyword `override` for declaring the function with prototype *func-prototype*. Since the function in *type-name* is not overriding a function from *other-type* with the same erasure, but with differences into the prototype such that your function is hidding the function of *other-type*. You function should be defined with `def` instead of `overrride`",
		"solution": "Replace `override` by `def`",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.obsolete_annotation_override",
		"message": "Superfluous @Override annotation",
		"cause": "From JAva language API, the annotation `@Override` is defined in order to mark a function as a function that is overridding another function. The usage of this annotation is not recommended, even it is still possible. This warning message is generated when the function is already defined with the `override` keyword, and annotated with `@Override`. In this case, the annotation is superfluous",
		"solution": "Remove `@Override`",
		"level": "warning"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.inconsistent_indentation",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.xbase_lib_not_on_classpath",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.jdk_not_on_classpath",
		"message": "SARL compiler couldn't be executed on the JDK version *current-version*. Please use the JDK greater than or equal to *min-version* AND strictly lower than *max-version*",
		"cause": "SARL needs a specific version of the Java Development Kit (JDK) in order to be executed. The *current-version* of the JDK is not compatible with SARL. It is recommended to use a JDK version between *min-version* (inclusive) and *max-version* (exclusive)",
		"solution": "Run SARL with an appropriate JDK version",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.jdk_not_on_classpath",
		"message": "Couldn't find a valid version of the JDK in the classpath. The generator configuration specifies the version *current-version*. Please change the configuration in order to use a version greater than or equal to *min-version* AND strictly lower than *max-version*",
		"cause": "SARL needs a specific version of the Java Development Kit (JDK) in order to be executed. The *current-version* of the JDK that is used for compiling your SARL project is not compatible with SARL. It is recommended to use a JDK version between *min-version* (inclusive) and *max-version* (exclusive)",
		"solution": "Change the configuration of your SARL project for using an appropriate JDK version",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.class_must_be_defined_abstract",
		"message": "The class *type-name* must be defined abstract because it does not implement *list-of-functions*",
		"cause": "You have defined abstract functions into *type-name*, or abstract functions are inherited without beeing implemented. In this case, the *type-name* must also be defined as `abstract` because abstract functions can only be defined into an abstract type",
		"solution": "Add `abstract` modifier to *type-name*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.anonymous_class_missing_members",
		"message": "The anonymous subclass of *type-name* does not implement *list-of-functions*",
		"cause": "Because anonymous class cannot be abstract, all the abstract functions that are inherited must be implemented into the anonymous class",
		"solution": "Implement the missed functions",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.anonymous_class_static_method",
		"message": "A method of an anonymous class cannot be static",
		"cause": "Because an anonymous class is not a named type, we cannot refer to its functions with a static notation (that is the name of the type, followed by the name of the function). Consequently, it is forbidden to define a static function into an anonymous class",
		"solution": "Remove `static` modifier from the function prototype",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.anonymous_class_static_field",
		"message": "A static field of an anonymous class must be final",
		"cause": "Because an anonymous class is a class, we can declare `static` fields for sharing data between the difference instances of the anonymous class (that is the usual usage of static fields for regular classes). However, because an anonymous class is attached to its enclosing context, any side-effect applied by the change of the static field's value must be avoided. That's why a static field in an anonymous class must be unmodifiable, i.e., defined with `val` or marked with the `final` modifier", 
		"solution": "Replace `var` keyword by `val`; or add the `static` modifier to the field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.duplicate_parameter_name",
		"message": "Duplicate parameter *name*",
		"cause": "You cannot define with the same *name* two formal parameters into the same function",
		"solution": "Rename one of the formal parameters",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.duplicate_parameter_name",
		"message": "Duplicate implicit parameter 'it'",
		"cause": "You cannot define with the same *name* two formal parameters into the same function. In the context of the erroneous code, an implicit parameter is defined and named `it`. You have also explicitly defined a formal parameter named `it`. There is a conflict between the names",
		"solution": "Rename your explicit formal parameter",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.overridden_final",
		"message": "Attempt to override final method *func-prototype*",
		"cause": "You define a function with the given prototype *func-prototype* that is overriding an inherited function. But, the inherited function was defined as not overridable, with the `final` modifier. You cannot override a function that is not overridable",
		"solution": "Remove your function",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.overridden_final",
		"message": "Attempt to override final class",
		"cause": "You define a class that is extending another class. But, the super class was defined as not extendable, with the `final` modifier. You cannot extend a class that is not extendable",
		"solution": "Change the super-type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.override_reduces_visibility",
		"message": "Cannot reduce the visibility of the overridden method *func-prototype*",
		"cause": "According the inheritance definition, that is common to SARL and the object-oriented programming languages, overridable functions as associated to a contract with their callers. This contract indicates that the prototype of the function will never changed, and the function will have the same accessibility/visibility always. This contract must be fullfil by the overriding functions. This error message is generated when your overriding function has a visibility lower than the visibility of the inherited function",
		"solution": "Change the visibility of your function by moving up at least to the same visibility as the inherited function",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.missing_synchronized",
		"message": "The overridden method is synchronized, the current one is not synchronized",
		"cause": "According the inheritance definition, that is common to SARL and the object-oriented programming languages, overridable functions as associated to a contract with their callers. This contract indicates that the prototype of the function will never changed, and the function will have the same modifiers always. This contract must be fullfil by the overriding functions. This warning message is generated when your overriding function has not the `synchronized` modifier, and the inherited function has the `synchronized` modifier. It is a good practice to exhibit the same modifiers as the inherited function",
		"solution": "Add `synchronized` modifier to your function",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.incompatible_throws_clause",
		"message": "The declared exception *exception-type* is not compatible with throws clause in *exception-list*",
		"cause": "According the inheritance definition, that is common to SARL and the object-oriented programming languages, overridable functions as associated to a contract with their callers. This contract indicates that the prototype of the function will never changed, and the function will have the same thrown exceptions always. This contract must be fullfil by the overriding functions. This error message is generated when your overriding function has a list of exceptions after the `thrown` keyword that is not compatible with the list defined into the inherited function. An exception of type \"a\" in the overriding function must be also a \"b\", where \"a\" is equals to \"b\" or a sub-type of \"b\"",
		"solution": "Change the list of exceptions after `throws` keyword to the appropriate exception types",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.cyclic_inheritance",
		"message": "The inheritance hierarchy of '*type-name*' is inconsistent",
		"cause": "According the inheritance definition, that is common to SARL and the object-oriented programming languages, cyclic into the inheritance hierarchy is totally forbidden",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.unused_private_member",
		"message": "The method *func-prototype* from the type *type-name* is never used locally",
		"cause": "This warning is generated because you have defined a private function that is never called. This is not a problem for running your program. But, it makes your binary executable file larger than stricly necessary",
		"solution": "Remove the private function",
		"level": "d/org.eclipse.jdt.core.compiler.problem.unusedPrivateMember/warning"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.field_not_initialized",
		"message": "The blank final field *name* may not have been initialized",
		"cause": "Final fields must be initialized when they are declared, or inside the enclosing type constructor (when writing a constructor is possible). You have declared a final field that is never initialized",
		"solution": "Add initialization value to the field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.field_not_initialized",
		"message": "The blank final derived field *name* may not have been initialized",
		"cause": "Final fields must be initialized when they are declared, or inside the enclosing type constructor (when writing a constructor is possible). You have declared a final field that is never initialized",
		"solution": "Add initialization value to the field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.exception_not_throwable",
		"message": "No exception of type *type-name* can be thrown; an exception type must be a subclass of Throwable",
		"cause": "You have specified a type after the `thrown` keyword that is not a subtype of `Throwable`. This type comes from the Java API, and represents all the throwable objects, e.g., the exceptions, into the virtual machine. You must given sub-types of `Throwable` after the `thrown` keyword",
		"solution": "Remove *type-name*; or replace it by an appropriate type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.exception_declared_twice",
		"message": "Exception *type-name* is declared twice",
		"cause": "You have declared two times the same exception after a `throw` keyword",
		"solution": "Remove one occurrence of *type-name*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.missing_constructor",
		"message": "No default constructor in super type *other-type*. *type-name* must define an explicit constructor",
		"cause": "You have define a type named *type-name* with a default constructor. But, the super-class does not have a default constructor. It is then impossible for your implicit default constructor to invoke a default constructor from the super-class. You must define explicitly your own constructor. *This issue should never occur because the constructors from the super type are inherited when there is no explicit constructor defined*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.must_invoke_super_constructor",
		"message": "No default constructor in super type *type-name*. Another constructor must be invoked explicitly",
		"cause": "You have define a type extending the type *type-name* and with an explicit constructor. Inside the code of this explicit constructor, you call the default constructor (implicitly or explicitly). But, the super-type does not have a default constructor",
		"solution": "Update you constructor code in order to invoke a constructor of the super-type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.constructor_type_params_not_supported",
		"message": "Type parameters are not supported for constructors",
		"cause": "A constructor cannot have generic type parameters",
		"solution": "Remove the generic type parameters",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.constructor_type_params_not_supported",
		"message": "Unexpected type parameter to a static constructor",
		"cause": "A static constructor cannot have generic type parameters",
		"solution": "Remove the generic type parameters",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.constructor_not_permitted",
		"message": "Contructors are only permitted within classes",
		"cause": "You try to define a construction in a type that cannot be mapped to a low-level class, e.g. class, agent, behavior, etc",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_use_of_static",
		"message": "Create methods can not be static",
		"cause": "Creation method is inspired from the [factory-method design pattern](https://en.wikipedia.org/wiki/Factory_method_pattern). It cannot be defined with the `static` modifier",
		"solution": "Remove the `static` modifier",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_use_of_static",
		"message": "Create methods can not have type parameters",
		"cause": "Creation method is inspired from the [factory-method design pattern](https://en.wikipedia.org/wiki/Factory_method_pattern). It cannot have generic type parameters",
		"solution": "Remove the generic type parameters",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_use_of_varArg",
		"message": "A vararg must be the last parameter",
		"cause": "By definition a variadic parameter, e.g., `a : int*`, must be the last formal parameter of a function",
		"solution": "Move the variadic parameter at the last position in the list of the formal parameters",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_use_of_varArg",
		"message": "A vararg may not be an extension",
		"cause": "By definition a variadic parameter, e.g., `a : int*` is a kind of list of argument values. Since the extension mechanism is associated to a single instance of object, and the variadic parameter may contains more than one, there is an incompatibility between the variadic parameter and the extension mechanism",
		"solution": "Remove the keyword `extension` to the variadic parameter",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_annotation_value_type",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_member_name",
		"message": "'it' and 'this' are not allowed as member names",
		"cause": "Names `it` and `this` are reserved by the SARL compiler. They cannot be used for naming your type members",
		"solution": "Change the name of your type member",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_member_name",
		"message": "The nested type *type-name* cannot hide an enclosing type",
		"cause": "You have define an inner type with a *name*. One of the enclosing types has also the same *name*. It is forbidden because it hides the features of the enclosing type from the inner type",
		"solution": "Rename your inner type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_member_name",
		"message": "Invalid action name '*name*'. You must not give to an action a name with reserved characters",
		"cause": "You have defined an name for an action/function/method that contains forbidden characters. The major forbidden character is &#x24;. It is not allowed to use it inside a name, even if it is allowed into the Java specification",
		"solution": "Rename your action",
		"level": "error"
	},
	{
		"code": "left_hand_side_must_be_variable",
		"message": "Left-hand side of an assignment must be an variable",
		"cause": "The left operand of the assignment operator `=` must be a variable (local, field, or indirect)",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.abstract_method_missing_return_type",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.abstract_method_with_body",
		"message": "Abstract methods do not specify a body",
		"cause": "You have defined a method within an interface of a capacity with an associated block of code. Since Java 1.8, the default implementation within interfaces (i.e., a block of code that may be considered as the function's implementation if the class implementing the interface is not providing its own code) is introduced. If you are using SARL upon an older Java environment, this error message is generated",
		"solution": "Remove the code block",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_modifier",
		"message": "Illegal modifier for the ; only *list-of-modifiers* are permitted",
		"cause": "You have used a modifier that is not allowed. The *list-of-modifiers* shows you the valid modifiers at the place of the issue",
		"solution": "Remove the modifier",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_modifier",
		"message": "Duplicate modifier for the *name*",
		"cause": "Duplicate modifiers are not allowed",
		"solution": "Remove the duplicate modifier",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_modifier",
		"message": "The *member-name* can only set one of public / package / protected / private",
		"cause": "You cannot specify more than one visibility modifier at a time",
		"solution": "Select and use one of the visibility modifiers",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_modifier",
		"message": "The *member-name* can either be abstract or final, not both",
		"cause": "It is forbidden to declare a function abstract and final at the same time. Indeed, a `final` function disables the function overriding, and an `abstract` function must be always overridden",
		"solution": "Remove one of the two modifiers",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_modifier",
		"message": "The *member-name* can either be abstract or static, not both",
		"cause": "It is forbidden to declare a function abstract and static at the same time. Indeed, a `static` function cannot be overridden, and an `abstract` function must be always overridden",
		"solution": "Remove one of the two modifiers",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_modifier",
		"message": "The *member-name* can either be var or val / final, not both",
		"cause": "`var` modifier is for declared a modifiable variable. `val` modifier (or `final val`) is for declaring a unmodifiable variable. You cannot use `var` and `val` at the same time",
		"solution": "Remove one of the two modifiers",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_modifier",
		"message": "Method *member-name* with a body cannot be abstract",
		"cause": "An abstract function is by definition a function without a body",
		"solution": "Remove the `abstract` modifier; or remove the block of code",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_modifier",
		"message": "Native methods do not specify a body",
		"cause": "A native function is always implemented by a very-low level library, usually written in C programming language. You cannot provide a block of code for a native function",
		"solution": "Remove the `native` modifier; or remove the block of code",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_modifier",
		"message": "Abstract method *member-name* cannot be final",
		"cause": "It is forbidden to declare a function abstract and final at the same time. Indeed, a `final` function disables the function overriding, and an `abstract` function must be always overridden",
		"solution": "Remove one of the two modifiers",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_modifier",
		"message": "Abstract method *member-name* cannot be private",
		"cause": "It is forbidden to declare a function abstract and private at the same time. Indeed, a `private` function cannot be overridden because it is not visible, and an `abstract` function must be always overridden",
		"solution": "Remove one of the two modifiers",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_modifier",
		"message": "Abstract method *member-name* cannot be static",
		"cause": "It is forbidden to declare a function abstract and static at the same time. Indeed, a `static` function cannot be overridden, and an `abstract` function must be always overridden",
		"solution": "Remove one of the two modifiers",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_modifier",
		"message": "The field *name* can be either final or volatile, not both",
		"cause": "It is forbidden to declare a field with the both modifiers at the same time. A `final` field does not need synchronization, that is provided by `volatile`",
		"solution": "Remove one of the two modifiers",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.missing_static_modifier",
		"message": "Nested classes must be static",
		"cause": "SARL specification forces to have static inner classes due to implementation of Xtext/Xtend",
		"solution": "Add `static` modifier to the nested class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.missing_abstract_modifier",
		"message": "The class *name* is not declared abstract",
		"cause": "The name of the class starts with the word `Abstract`, and the class has not the `abstract` modifier. Because the term \"abstract\" is part of the name of the class, it is a good practice to declare the class as abstract",
		"solution": "Add `abstract` modifier to the class; or remove \"Abstract\" from *name*",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.wildcard_in_supertype",
		"message": "The type *type-name* cannot extend or implement *other-type*. A supertype may not specify any wildcard",
		"cause": "The super-type named *other-type* is defined with wildcard into its generic type parameters. It is forbidden to extends or implement a super-type with a wildcard",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_extension_type",
		"message": "The primitive type *name* is not a valid extension",
		"cause": "[Extension on fields](./general/Extension.md) is supported by SARL syntax. The purpose is to call the member of an object or a type that is marked by `extension`. A primitive type has no member. Consequently, using the `extension` on a variable of primitive type is impossile",
		"solution": "Remove `extension`; or replace the primitive type by its object-oriented equivalent",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_operator_signature",
		"message": "The static operator '*name*' requires at least one argument",
		"cause": "You try to use the operator *name* without argument, when it requires at least one",
		"solution": "Rewrite the expression with the failing operator",
		"level": "c/error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_operator_signature",
		"message": "The static operator '*name*' allows at most two arguments",
		"cause": "You try to use the operator *name* without operand, when it requires at least one",
		"solution": "Rewrite the expression with the failing operator",
		"level": "c/error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_operator_signature",
		"message": "The static unary operator '*name*' requires exactly one argument",
		"cause": "You try to use the operator *name* with a number of operand that is not equal to 1; that is not allowed",
		"solution": "Rewrite the expression with the failing operator",
		"level": "c/error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_operator_signature",
		"message": "The static binary operator '*name' requires exactly two arguments",
		"cause": "You try to use the operator *name* with zero or one operand; that is not allowed",
		"solution": "Rewrite the expression with the failing operator",
		"level": "c/error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_operator_signature",
		"message": "The operator '*name*' allows at most two arguments",
		"cause": "You try to use the operator *name* with more than two operands; that is not allowed",
		"solution": "Rewrite the expression with the failing operator",
		"level": "c/error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_operator_signature",
		"message": "The unary operator '*name*' allows at most one argument",
		"cause": "You try to use the operator *name* with more than 1 operand; that is not allowed",
		"solution": "Rewrite the expression with the failing operator",
		"level": "c/error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_operator_signature",
		"message": "The binary operator '*name*' requires at least one argument",
		"cause": "You try to use the operator *name* with zero operand; that is not allowed",
		"solution": "Rewrite the expression with the failing operator",
		"level": "c/error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_operator_signature",
		"message": "The binary operator '*name*' allows at most two arguments",
		"cause": "You try to use the operator *name* with zero or one operand; that is not allowed",
		"solution": "Rewrite the expression with the failing operator",
		"level": "c/error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.processing_error",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.orphan_element",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.active_annotation_in_same_project",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.api_type_inference",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.implicit_return",
		"message": "Implicit return",
		"cause": "By default, it is not necessary to specify an explicit `return` statement inside the code block of a function. The SARL compilier assumes that the last executed instruction gives the value to be returned by the function. This issue message is generated when an implicit return is used within a function",
		"solution": "Add an explicit `return`",
		"level": "c/ignore"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.unnecessary_modifier",
		"message": "The private modifier is unnecessary on *member-name*",
		"cause": "This issue message is generated when the modifier `private` is specified on a member that has a default visibility equals to `private` also",
		"solution": "Remove the `private` modifier",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.unnecessary_modifier",
		"message": "The protected modifier is unnecessary on *member-name*",
		"cause": "This issue message is generated when the modifier `protected` is specified on a member that has a default visibility equals to `protected` also",
		"solution": "Remove the `protected` modifier",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.unnecessary_modifier",
		"message": "The package modifier is unnecessary on *member-name*",
		"cause": "This issue message is generated when the modifier `package` is specified on a member that has a default visibility equals to `package` also",
		"solution": "Remove the `package` modifier",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.unnecessary_modifier",
		"message": "The public modifier is unnecessary on *member-name*",
		"cause": "This issue message is generated when the modifier `public` is specified on a member that has a default visibility equals to `public` also",
		"solution": "Remove the `public` modifier",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.unnecessary_modifier",
		"message": "The final modifier is unnecessary on *member-name*",
		"cause": "Usually, this issue is generated when the `final` modifier is redundant with another modifer like `val`",
		"solution": "Remove the `final` modifier",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.unnecessary_modifier",
		"message": "The def modifier is unnecessary on *member-name*",
		"cause": "Usually, this issue is generated when the `def` modifier is redundant with another modifer like `override`",
		"solution": "Remove the `def` modifier",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.invalid_return_type_in_case_of_junit_annotation",
		"message": "JUnit method *func-name* must be void but is *type-name*",
		"cause": "By specification, the functions that are dedicated to JUnit must return void. This issue is generated when an function with a JUnit annotation does not return `void`. The supported versions of Junit are 4 and 5",
		"solution": "Replace the return type by `void`",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtend.core.validation.IssueCodes.ternary_if_operator_is_not_allowed",
		"message": "The ternary operator is not allowed. Use a normal if-expression",
		"cause": "The ternary operator is the inline if-then-else expression. In some best programming practices, the inline if-then-else are considered as a bad practice. This issue message is generated when an ternary operator is used in your code",
		"solution": "Replace the ternary operator by the equivalent if-then-else statement",
		"level": "c/ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.abstract_class_instantiation",
		"message": "Cannot instantiate the abstract type *type-name*",
		"cause": "This error is generated when you try to create an instance of an abstract class",
		"solution": "Replace *type-name* by the name of a concrete class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.ambiguous_feature_call",
		"message": "Ambiguous *feature-call*. The *feature-type* *feature-1* and *feature-2* both match",
		"cause": "You are calling a feature (method, field, etc.). But, the target feature is ambiguous. Multiple candidates were found within the scope of your call. SARL compiler cannot choose the concrete feature to be called. In order to help you, the SARL compiler provides to you the list of candidates",
		"solution": "Rewrite your code in order to remove the ambiguity",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.ambiguous_feature_call",
		"message": "Ambiguous *feature-call*. The *feature-type* *list-of-features* and *feature-2* all match",
		"cause": "You are calling a feature (method, field, etc.). But, the target feature is ambiguous. Multiple candidates were found within the scope of your call. SARL compiler cannot choose the concrete feature to be called. In order to help you, the SARL compiler provides to you the list of candidates",
		"solution": "Rewrite your code in order to remove the ambiguity",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_case",
		"message": "Duplicate case",
		"cause": "Into a `switch` statement, you have specified multiple times the same `case`, i.e., with the same case expression. Then, it is impossible to branch to a single `case` from the expression evaluated by the `switch` statement. This ambiguous branching is forbidden",
		"solution": "Remove one of the cases; or merge the two cases into a single case",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.redundant_case",
		"message": "Redundant case",
		"cause": "You have written a case without block of code that falls through the default case. It may be a piece of code like:\n&p.lt;code&p.gt;switch (v) {&p.lt;br&p.gt;&nbsp;&nbsp;case 1,&p.lt;br&p.gt;}&p.lt;/code&p.gt;\nIt is clear that `case 1` falls through a case that is not given. In this case, it is considered as an error because the fall-through cannot be implemented",
		"solution": "Remove the fall-through case; or add a block of code to the redundant case",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.redundant_case",
		"message": "Redundant case",
		"cause": "You have written a case without block of code that falls through the default case. It may be a piece of code like:\n&p.lt;code&p.gt;switch (v) {&p.lt;br&p.gt;&nbsp;&nbsp;case 1,&p.lt;br&p.gt;&nbsp;&nbsp;default: {}&p.lt;br&p.gt;}&p.lt;/code&p.gt;\nIt is clear that `case 1` is redundant with `default` since this last is covering the `1` value",
		"solution": "Remove the redundant case",
		"level": "warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.suspiciously_overloaded_feature",
		"message": "Suspiciously overloaded method. The *feature-type* *list-of-features* overloads the *feature-type* *list-of-rejected-features*",
		"cause": "You are calling a feature (method, field, etc.). The target feature that is find by the SARL compiler seems to overload another feature, but not direct through an overriding. Indeed, with the extension method mechanism, candidates for being the target feature may be defined in the current type (regular linking), or imported from static types or from objects (extension linking). The selected target feature seems to hide another feature outside the inheritance mechanism between the types",
		"solution": "Rewrite your code to remove the suspicious call",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.no_illegal_value",
		"message": "The value for an annotation attribute must be a constant expression",
		"cause": "It is forbidden to give a value to an annotation that is not a constant expression, i.e., an expression without variable reference, function calls, etc",
		"solution": "Rewrite the value expression to have only constant features inside",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.no_attribute_value",
		"message": "The attribute value is undefined for the annotation type *name*",
		"cause": "You are trying to provide a value to an annotation, but the field `value` is not defined into the annotation.\nThis error may occur when you write `@MyAnnotion(\"value\")` with a definition of `MyAnnotation` without a field named `value`. In this example, assuming that the declared field is named `myfield`, the correct notation is `@MyAnnotation(myfield = \"value\")`.\nAs for other languages as Java, SARL assumes that if the name of the attribute is not provided, the default attribute name is `value`",
		"solution": "Add the name of the attribute before the value",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.missing_attribute_definition",
		"message": "The annotation must define the attribute '*name*'",
		"cause": "An annotation needs to have a specified value. This error message is generated when no value is specified into the annotation",
		"solution": "Add a value to the annotation",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.assignment_to_final",
		"message": "Assignment to final variable",
		"cause": "You try to assign a value to a variable that is declared as final, e.g., `val myvar` or `final var myvar`. Since the variable is declared as final, its value cannot be changed",
		"solution": "Remove the final modifier on the variable; or assign to another not-final variable",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.assignment_to_final",
		"message": "Assignment to final parameter",
		"cause": "You try to assign a value to a parameter. Parameters are always considered as final from the SARL specification. Since the parameter is declared as final, its value cannot be changed",
		"solution": "Assign to another not-final variable",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.assignment_to_final",
		"message": "Assignment to final field",
		"cause": "You try to assign a value to a field that is declared as final, e.g., `val myvar` or `final var myvar`. Since the field is declared as final, its value cannot be changed",
		"solution": "Remove the final modifier on the field; or assign to another not-final field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.assignment_to_no_variable",
		"message": "The left-hand side of an assignment must be a variable",
		"cause": "According to the definition of the assignment operator, the left operand must always be a variable or a field that is not declared as final. When this error message is generated, it means that the left operand is neither a variable nor a field.\nPlease not that the use of the assignment operator may be considered as a call to a \"setter\" function. In this case, this error message is not generated",
		"solution": "Replace the left operand with an appropriate variable or field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.circular_constructor_invocation",
		"message": "Recursive constructor invocation",
		"cause": "You have defined several constructors into your type that are calling other constructors in the type. The sequence of constructor's calls contains a loop; that is forbidden. An example of failing code is:\n&p.lt;code&p.gt;class X {&p.lt;br&p.gt;&nbsp;&nbsp;new (x : int) {&p.lt;br&p.gt;&nbsp;&nbsp;&nbsp;&nbsp;this('c')&p.lt;br&p.gt;&nbsp;&nbsp;}&p.lt;br&p.gt;&nbsp;&nbsp;new (x : char) {&p.lt;br&p.gt;&nbsp;&nbsp;&nbsp;&nbsp;this(1)&p.lt;br&p.gt;&nbsp;&nbsp;}&p.lt;br&p.gt;}&p.lt;/code&p.gt;",
		"solution": "Rewrite your code to avoid cyclic calls to the constructors",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invisible_feature",
		"message": "Cannot access the private *feature* in a subclass context",
		"cause": "You try to access to a field that is declared as `private` into the super-type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invisible_feature",
		"message": "The method *feature* is not visible",
		"cause": "You try to access to a method that is declared as `private` into its enclosing type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invisible_feature",
		"message": "The field *feature* is not visible",
		"cause": "You try to access to a field that is declared as `private` into its enclosing type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.field_access_with_parentheses",
		"message": "Cannot access the *type-name* *feature-name* with parentheses",
		"cause": "This error is generated when you try to access to a field with parentheses. Let be the field `x` defined. The code `x()` causes this error because `x` is a field, not a method",
		"solution": "Remove the parentheses",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.illegal_forward_reference",
		"message": "Cannot reference the field '*name*' before it is defined",
		"cause": "You try to have access to a field before it is defined within the sequence of statements ofyour code. This error should never append in SARL code. It was defined for \"safety\" reasons",
		"solution": "Move the field definition before its first usage",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.illegal_class_instantiation",
		"message": "Cannot instantiate the primitive type *name*",
		"cause": "You try to create an instance of a primitive type named *name* with the `new` instruction. Since a primitive type is not object-oriented, it is impossible to create an instance of primitive type",
		"level": "error"
	},

	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.illegal_class_instantiation",
		"message": "Cannot instantiate the annotation type *name*",
		"cause": "You try to create an instance of an annotation named *name* with the `new` instruction. It is impossible to create an instance of annotation",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.illegal_class_instantiation",
		"message": "Cannot instantiate the enum type *name*",
		"cause": "You try to create an instance of an enumeration named *name* with the `new` instruction. It is impossible to create an instance of enumeration",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.illegal_class_instantiation",
		"message": "Cannot instantiate the interface type *name*",
		"cause": "You try to create an instance of an interface named *name* with the `new` instruction. It is impossible to create an instance of interface",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.illegal_class_instantiation",
		"message": "Cannot instantiate the type parameter *name*",
		"cause": "You try to create an instance of a type parameter named *name* with the `new` instruction. Since the concrete type represented by the type parameter is not known at compile time, creation of an instance of *name* is impossible",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.illegal_class_instantiation",
		"message": "Cannot instantiate the *name*",
		"cause": "You try to create an instance of a type named *name* with the `new` instruction. The type with the given *name* cannot be instanciated due to several reasons, e.g., it is defiend as abstract, it has no visible constructor, etc",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.incomptible_return_type",
		"message": "The return type is incompatible with *func-prototype*",
		"cause": "This error message is generated when an overriding function has a specified return type that is incompatible with the return type defined into the super-type",
		"solution": "Replace the return type with a compatible type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.incompatible_types",
		"message": "Incompatible types. Expected *expected-type* but was *actual-type*",
		"cause": "The value that is specified after a `return` statement has a type that is incompatible with the return type of the enclosing function",
		"solution": "Rewrite the return's expression in order to have a compatible type; or change the return type of the function to be compatible with those of the return expression",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.incompatible_types",
		"message": "No exception of type *type-name* can be thrown; an exception type must be a subclass of Throwable",
		"cause": "Inside a `catch` statement, you have specified a *type-name* that does not correspond to a sub-type of `Throwable`. The parameter of the `catch` statement must be a throwable type, or a collection of throwable types",
		"solution": "Rewrite *type-name* by an appropriate throwable type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.instance_access_to_static_member",
		"message": "The static *feature-type* *feature-name* should be accessed in a static way",
		"cause": "For a instance function, you try to access to a static feature using a non-static syntax, e.g. `obj.StaticFeature`. It is preferable to use the static call syntax, e.g. `MyType::StaticFeature`, where `MyType` is the type of the object `obj` from the previous example",
		"solution": "Replace the non-static syntax by the static syntax",
		"level": "d/org.eclipse.jdt.core.compiler.problem.staticAccessReceiver/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_argument_types",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_operand_types",
		"message": "Incompatible operand types *left* and *right*",
		"cause": "When you are testing expression equality with `===`, the types of the operands are not compatible. It means that the values of the operands cannot be compared",
		"solution": "Rewrite your code in order to have compatible types for both operands",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_cast",
		"message": "Cannot cast from *type-name-1* to *type-name-2*",
		"cause": "The operands of the cast operator `as` have not compatible types. SARL compiler has found no way to convert a value of the type with name *type-name-1*, which is the type of the left operand of the `as` operator, to a value of the type with name *type-name-2*, which is the right operand of the `as` operator",
		"solution": "Change the left expression in order to be of a compatible type with the right operand; or Replace *type-name-2* by an appropriate type name; or Define a \"to*type-name-2*()\" function if *type-name-2* is a class; or Define a \"*type-name-2Value()\" function if *type-name-2* is a primitive type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_cast",
		"message": "Cannot cast from void to *type-name-2*",
		"cause": "Since `void` represents the fact that there is not value, it is impossible to convert \"nothing\" to a value, whatever its type",
		"solution": "Remove `as` operator",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.java_style_type_cast",
		"message": "Use 'as' keyword for type casting",
		"cause": "SARL has detected possible improper usage of the parentheses, i.e., a type reference enclosed by parentheses is found. This syntax is well known is other programming languages such as Java or C++, as the casting operator. However, the casting operator in SARL is `as`. For example, this error is detected when you starts a code block with the improper syntax, e.g. `{(Integer) 1}`",
		"solution": "Replace the Java-like casting operator by `as`",
		"level": "c/error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_constructor_invocation",
		"message": "Constructor call must be the first expression in a constructor",
		"cause": "According to the standards of object-oriented programming, nothing could append into an object before it was constructed. It means that the first possible instruction within any constructor's code is a call to another constructor. This call may be explicit or implicit. This error is generated by your constructor's code starts with statements that are not a constructor calls, followed by a constructor call",
		"solution": "Move the constructor call first",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_constructor_argument",
		"message": "Cannot refer to an instance field *field-name* while explicitly invoking a constructor",
		"cause": "According to the standards of object-oriented programming, nothing could append into an object before it was constructed. It means that when you are calling a constructor from inside a constructor's block of code, the object is not yet built. Consequently, you cannot have access to the object's fields (not static)",
		"solution": "Rewrite the arguments to avoid the access to the object's field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_constructor_argument",
		"message": "Cannot refer to an instance method while explicitly invoking a constructor",
		"cause": "According to the standards of object-oriented programming, nothing could append into an object before it was constructed. It means that when you are calling a constructor from inside a constructor's block of code, the object is not yet built. Consequently, you cannot have access to the object's method (not static)",
		"solution": "Rewrite the arguments to avoid the access to the object's method",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_early_exit",
		"message": "A return expression is not allowed in this context",
		"cause": "This error message is generated when a `return` statement is defined in a context that cannot allow a return",
		"solution": "Remove the `return` statement",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_early_exit",
		"message": "A throw expression is not allowed in this context",
		"cause": "This error message is generated when a `throw` statement is defined in a context that cannot allow to throw exceptions",
		"solution": "Remove the `throw` statement",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_generic_argument_types",
		"message": "*any-message*",
		"cause": "This error message is generated when you pass an invalid type to a generic parameter type. *Caution: this issue seems not to have a message template from the Xtext/Xbase source code*",
		"solution": "Change the type argument",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_inner_expression",
		"message": "This expression is not allowed in this context, since it doesn't cause any side effects",
		"cause": "This error is generated when you write an expression without side effect, where one is expected. For example, the following code generates this error:\n&p.lt;code&p.gt;def fct : void {&p.lt;br&p.gt;&nbsp;&nbsp;var x = 1&p.lt;br&p.gt;}&p.lt;/code&p.gt;\nIn this case, the variable declaration has not side effect; and should not be used in this context",
		"solution": "Remove the expression without side-effect",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_inner_expression",
		"message": "Expression with side effect is not allowed in guards",
		"cause": "The guard that is specified for a behavior unit may have side effect, i.e. it may modify the state of the current agent/behavior/skill, or of another object. According to the SARL specification, the behavior units' guards must not have any side-effect because the guard's expression could be evaluated in parallel for different behavior units on the same event. In order to be consistent between the different evaluations of the guard, the guard expression cannot change the state of any object",
		"solution": "Rewrite the guard expression to avoid the uses of side-effect expressions",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_instanceof",
		"message": "Cannot perform instanceof check against parameterized type *type-name*",
		"cause": "You have written a `instanceof` operator with a right operand containing a generic type parameter, e.g. `x instanceof MyType&p.lt;T&p.gt;`. It is impossible for now to the SARL compiler to consider the generic type parameter, e.g. `T`",
		"solution": "Remove the generic type parameter from the right operand's expression",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_instanceof",
		"message": "Cannot perform instanceof check against primitive type *type-name*",
		"cause": "You have written a primitive type as right operand of the `instanceof` operator. Since a primitive type is not object-oriented, it is impossible to test if an object is of a primitive type using the `instanceof` operator",
		"solution": "Remove `instanceof` operator; or Replace the primitive type by its object-oriented equivalent type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_instanceof",
		"message": "Incompatible conditional operand types *type-name-1* and *type-name-2*",
		"cause": "When you are testing expression typing with `instanceof`, the types of the operands are not compatible. It means that the values of the operands cannot be compared. Therefore, the `instanceof` operator becomes useless",
		"solution": "Remove the `instanceof` operator; or Rewrite the `instanceof` expression to have compatible types for both operands",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_mutable_variable_access",
		"message": "Cannot *expression* refer to the non-final variable *var-name* inside a lambda expression",
		"cause": "You have written an expression inside a closure/lambda expression that is referring a variable that is not marked as final. In this case, the state of the variable becomes unpredictable for the internal class that is supporting the lambda expression implementation (due to the targeting to Java). That's why only final (or quasi-final) variables could be used in lambda expressions",
		"solution": "Replace `var` definition of the variable by a `var` definition; or Use another final variable from the lambda expression",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_number_of_arguments",
		"message": "Invalid number of arguments. The *feature-type* *feature-prototype* is not applicable without arguments",
		"cause": "You are calling a feature (method or constructor) without arguments. But, the called feature required to have arguments",
		"solution": "Add arguments into your calling expression",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_number_of_arguments",
		"message": "Invalid number of arguments. The *feature-type* *feature-prototype* is not applicable for the arguments *list-of-arguments*",
		"cause": "You are calling a feature (method or constructor) with a *list-of-arguments*. But, the called feature required a different number of arguments",
		"solution": "Call the feature with the correct number of arguments",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_number_of_type_arguments",
		"message": "Incorrect number of arguments for type *type-name* ; it cannot be parameterized with arguments *type-arguments*",
		"cause": "You are referencing a type with a list of generic type arguments (*list-arguments*). But, the referenced type required a different number of generic type arguments",
		"solution": "Reference the type with the correct number of arguments",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_number_of_type_arguments",
		"message": "Invalid number of type arguments. The *feature-type* *feature-name* is not applicable for the type arguments *type-arguments*",
		"cause": "You are calling a feature (method or constructor) with a list of generic type arguments (*list-arguments*). But, the feature required a different number of generic type arguments",
		"solution": "Call the feature with the correct number of arguments",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_wildcard_constraints",
		"message": "Invalid type constraint. Cannot use multiple upper bounds in wildcards",
		"cause": "Inside a type reference, you have specified a type constraints with too much upper bounds, e.g. `new MyType&p.lt;? extends Number &amp; CharSequence&p.gt;`. Currently, SARL does not support multiple upper bounds into the generic type references",
		"solution": "Modify the bounds to have maximum one upper bound",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_wildcard_constraints",
		"message": "Invalid type constraint. Cannot use multiple lower bounds in wildcards",
		"cause": "Inside a type reference, you have specified a type constraints with too much lower bounds, e.g. `new MyType&p.lt;? super Number &amp; CharSequence&p.gt;`. Currently, SARL does not support multiple lower bounds into the generic type references",
		"solution": "Modify the bounds to have maximum one lower bound",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.type_argument_on_non_generic_type",
		"message": "The type *type-name* is not generic; it cannot be parameterized with arguments *type-arguments*",
		"cause": "You have specified generic type parameters to a type that does not accept generic type parameters, e.g. `Object&p.lt;String&p.gt;`, `int&p.lt;String&p.gt;`, `MyEnum&p.lt;String&p.gt;`, `MyAnnotation&p.lt;String&p.gt;`",
		"solution": "Remove the generic type parameters",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_return",
		"message": "Invalid return inside throw",
		"cause": "It is forbidden to specify a `return` statement into a `throw` expression because the outer early-exit point (`throw`) could be never reached due to the execution of the inner early-exit point (`return`). It is inconsistent to do a regular return for a function inside the expression of an exceptional exit from the same function",
		"solution": "Remove `return` from the `throw` expression",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_return",
		"message": "Return cannot be nested",
		"cause": "It is forbidden to specify a `return` statement into another `return` expression because the outer early-exit point could be never reached due to the execution of the inner early-exit point. It is inconsistent to do a return for a function inside the expression that computes another value to be returned from the same function",
		"solution": "Remove the inner `return` from the outer `return` expression",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_return",
		"message": "Invalid return's expression",
		"cause": "SARL compiler infers that the type of the expression after a `return` statement is of type `void`. It is impossible to return \"nothing\" when a value is expected",
		"solution": "Change the return expression in order to compute a value of the appropriate type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_return",
		"message": "Void functions cannot return a value",
		"cause": "You are specifying a `return` statement with an expression inside a procedure, i.e. a function returning \"nothing\". Is it inconsistent to compute a value to be returned while the function does not return it",
		"solution": "Remove the expression from the `return` statement",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_return",
		"message": "The function must return a result of type *type-name*",
		"cause": "An incompatibility between the type of the expression after a `return` statement and those of the return value of the enclosing function is detected. Both types must be compatible, i.e., the type of the expression after the `return` statement must be equal to or a sub-type of the function's return type",
		"solution": "Update the expression of the `return` statement to have an appropriate type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "The primitive type cannot be a type argument",
		"cause": "It is forbidden to put primitive types as generic type parameters, e.g. `Collection&p.lt;int&p.gt;`. You must use only classes as generic type parameters, e.g. `Collection&p.lt;Integer&p.gt;`",
		"solution": "Replace the primitive type by its appropriate equivalent class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "The primitive 'void' cannot be the type of a parameter",
		"cause": "A formal parameter must have a type. Consequently, `void` cannot be specified as the type of a formal parameter",
		"solution": "Replace `void` by an appropriate type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "The primitive 'void' cannot be the type of a function parameter",
		"cause": "This error is generated when a reference to a function, a.k.a. as pointer to a function, is specified with a `void` type. A function has parameters and returns values. It is not `void`",
		"solution": "Replace `void` by an appropriate pointer to a function",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "Primitive void cannot be used here",
		"cause": "This message is generated in to cases.\na) Generic type argument: it is forbidden to put primitive `void` as generic type arguments, e.g. `Collection&p.lt;void&p.gt;`.\nb) Guard type into a switch case: it is forbidden to put primitive `void` as guard type, e.g. `void case 1`",
		"solution": "Replace `void` by its appropriate equivalent class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "void is an invalid type for the variable *name*",
		"cause": "Since a variable is supposed to contain a value, it is important to specify the size of memory that is occupied bythe variable. This specification is done by giving a type to the variable. `void` is not a valid type in this context",
		"solution": "Replace `void` by an appropriate type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "Primitives cannot be used as type arguments",
		"cause": "It is forbidden to put primitive types as generic type arguments, e.g. `Collection&p.lt;int&p.gt;`. You must use only classes as generic type arguments, e.g. `Collection&p.lt;Integer&p.gt;`",
		"solution": "Replace the primitive type by its appropriate equivalent class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "Primitives cannot be used as type arguments",
		"cause": "It is forbidden to put primitive types as generic type arguments, e.g. `Collection&p.lt;int&p.gt;`. You must use only classes as generic type arguments, e.g. `Collection&p.lt;Integer&p.gt;`",
		"solution": "Replace the primitive type by its appropriate equivalent class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "Primitives are not allowed as type guards",
		"cause": "It is forbidden to put primitive type as guard type, e.g. `int case 1`",
		"solution": "Replace the primitive type by its appropriate equivalent class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_wild_card",
		"message": "Wildcard types are not allowed in this context",
		"cause": "It is forbidden to put wildcard as generic type parameters, e.g. `Collection&p.lt;?&p.gt;`. You must use only classes as generic type parameters, e.g. `Collection&p.lt;Integer&p.gt;`",
		"solution": "Replace the wildcard by an appropriate class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.local_var_access_with_parentheses",
		"message": "Cannot access the *type-name* *feature-name* with parentheses",
		"cause": "This error is generated when you try to access to a local variable with parentheses. Let be the local variable `x` defined. The code `x()` causes this error because `x` is a variable, not a method",
		"solution": "Remove the parentheses",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.method_access_without_parentheses",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.missing_initialization",
		"message": "Value must be initialized",
		"cause": "Final variables, a.k.a. value, could be declared with `val`, and must be initialized when they are declared. You have declared a final variable that is never initialized",
		"solution": "Add initialization value to the final variable",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.missing_type",
		"message": "Missing implemented type '*type-name-1*' for '*type-name-2*'",
		"cause": "SARL detects for the declaration of the type named *type-name-2* that an implementation specification after `implements` is missed. The expected implementation must be a type that is equal to or a sub-type of the type named *type-named-1*",
		"solution": "Add an appropriate implemented type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.missing_type",
		"message": "Type cannot be derived",
		"cause": "Within a variable declaration with `var` or `val`, no type was specified. SARL was failed to infer the type of the variable, notably because an initialization expression is missed for the variable. Because a variable must have a type, it is forbidden to let the variable type free",
		"solution": "Add an explicit type to the variable, or Add an initialization expression for the variable",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.obsolete_cast",
		"message": "Unnecessary cast from *type-name-1* to *type-name-2*",
		"cause": "You are using a cast operator `as`. But, the type of the left-operand expression is already compatible with the specified type as right operand. In other words, it is not necessary to cast explicitly the left expression to the right type",
		"solution": "Remove `as` operator",
		"level": "d/org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.obsolete_instanceof",
		"message": "The expression of type *type-name-1* is already of type *type-name-2*",
		"cause": "You are using `instanceof`. But, the type of the left-operand expression is already compatible with the specified type as right operand. In other words, it is not necessary to test the type of the expression again the type; or the `instanceof` operator is always evaluated to true",
		"solution": "Remove `instanceof` operator, and any \"else\" statement that is associated with the operator",
		"level": "d/org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.static_access_to_instance_member",
		"message": "Cannot make a static reference to the non-static *feature-type* *feature-name* from the type *type-name*",
		"cause": "You are making a reference to a non-static feature (function call or field reference) from a static context within the type *type-name*. Accessing to a non-static feature needs to provide the instance of the object to access to; that is missed from a static context",
		"solution": "Add the missed object reference",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.static_access_to_instance_member",
		"message": "Cannot make a static reference to the non-static *feature-type* *feature-name*",
		"cause": "You are making a reference to a non-static feature (function call or field reference) from a static context. Accessing to a non-static feature needs to provide the instance of the object to access to; that is missed from a static context",
		"solution": "Add the missed object reference",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.static_access_to_instance_member",
		"message": "Cannot make a static reference to the non-static type *name*",
		"cause": "When you are defining the generic type arguments, you have to specify types as arguments, e.g. `Collection&p.lt;MyType&p.gt;`. Generic type arguments could only refer to statically declared types",
		"solution": "Replace the non-static type reference by an appropriate static type reference",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.static_access_to_instance_member",
		"message": "Cannot make an implicit reference to this from a static context",
		"cause": "You are making an implicit reference to the current object `this` from a static context. Since it is a static context, `this` does not exist or is not accessible from it",
		"solution": "Add the missed object reference",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.static_access_to_instance_member",
		"message": "Cannot use *name* in a static context",
		"cause": "You cannot reference a type with *name* from a static context when the type *name* is not statically defined",
		"solution": "Replace the non-static type reference by an appropriate static type reference",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.static_access_to_instance_member",
		"message": "Cannot make an implicit static reference to the non-static extension *name*",
		"cause": "You have defined a non-static extension in the enclosing code. And , you are making a reference to a non-static extension feature (function call usually) from a static context. Accessing to a non-static feature needs to provide the instance of the object to access to; that is missed from a static context",
		"solution": "Replace implicit reference by explicit reference to the right object",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.no_enclosing_instance_available",
		"message": "The enclosing type does not extend or implement the interface *name*",
		"cause": "Your are calling a feature (method or field) from the super-type by using the syntax `super.feature`. The super-type does not implement the interface *name* that is required to access to the specified feature",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.no_enclosing_instance_available",
		"message": "No enclosing instance of the type *name* is accessible in scope",
		"cause": "You are referencing a feature within the type *type* that is defined non-statically. But, these is no accessible instance of the type *name* within the enclosing types. The following example is a typical example for this error:\n&p.lt;code&p.gt;class A {&p.lt;br&p.gt;&nbsp;&nbsp;def f : void {}&p.lt;br&p.gt;&nbsp;&nbsp;static class B {&p.lt;br&p.gt;&nbsp;&nbsp;&nbsp;&nbsp;def g : void {&p.lt;br&p.gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&p.lt;br&p.gt;&nbsp;&nbsp;&nbsp;&nbsp;}&p.lt;br&p.gt;&nbsp;&nbsp;}&p.lt;br&p.gt;}&p.lt;/code&p.gt;\nThe reference to `f` causes this error because the instance of `A` is inaccessible from `B` due to its `static` declaration",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.too_little_type_information",
		"message": "Cannot infer type from recursive usage. Type 'Object' is used",
		"cause": "You code has a type-free feature, e.g. a local variable. SARL cannot infer the type of the feature because a cycle is detected regarding the type definitions",
		"solution": "Define explicitly the type of the feature",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.too_little_type_information",
		"message": "Cannot infer type",
		"cause": "It is too complex for the SARL compiler to infer the type of the marked feature",
		"solution": "Define explicitly the type of the feature",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.too_little_type_information",
		"message": "There is no context to infer the closure's argument types from. Consider typing the arguments or put the closures into a typed context",
		"cause": "This error is generated when the SARL compiler cannot infer the type of a formal parameter of a closure/lambda expression from the usage context",
		"solution": "Define explicitly the formal parameters within the closure; or Make more explicit within the enclosing context the type of the closure's formal parameter",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.too_little_type_information",
		"message": "There is no context to infer the closure's argument types from. Consider typing the arguments or use the closures in a more specific context",
		"cause": "This error is generated when the SARL compiler cannot infer the type of the first formal parameter of a closure/lambda expression from the usage context",
		"solution": "Define explicitly the formal parameters within the closure; or Make more explicit within the enclosing context the type of the closure's first formal parameter",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.too_many_params_in_closure",
		"message": "The maximum number of parameters for a closure is six",
		"cause": "A constrain given by the underground Java API is the maximum number of formal parameters that could be defined for a closure/lambda expression",
		"solution": "Reduce the number of formal parameters of your closure",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unexpected_invocation_on_type_literal",
		"message": "The syntax for type literals is typeof(*name*) or *name",
		"cause": "The type literal, i.e. the name of the type, with *name* must follow a string syntax, that is explained in the error message",
		"solution": "Use the correct syntax",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unhandled_exception",
		"message": "Unhandled exception type *type-name* thrown by automatic close() invocation on *feature*",
		"cause": "An exception is declared to be throwable by the `close()` function, which is automatically/implicitly invoked. This exception is not catched. This is not an error stricly because SARL compiler is able to propagate the definition of the exceptions to the enclosing function or constructor",
		"solution": "Add `catch` statement",
		"level": "c/ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unhandled_exception",
		"message": "Unhandled exception types *type-name-1* and *type-name-2*",
		"cause": "Exceptions have been declared to be throwable by instructions within the code block of an method or a constructor. But, the method or the constructor has no declaration of *type-name-1* and *typename-2* with `throws`. This is not an error stricly because SARL compiler is able to propagate the definition of the exceptions to the enclosing function or constructor",
		"solution": "Add *type-name-1* and *type-name-2* to `throws`",
		"level": "c/ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unhandled_exception",
		"message": "Unhandled exception type *type-name*",
		"cause": "Exception *type-name* has been declared to be throwable by instructions within the code block of an method or a constructor. But, the method or the constructor has no declaration of *type-name* with `throws`. This is not an error stricly because SARL compiler is able to propagate the definition of the exceptions to the enclosing function or constructor",
		"solution": "Add *type-name* to `throws`",
		"level": "c/ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_code",
		"message": "Unreachable expression",
		"cause": "This error message is generated when a line of code cannot be reached in all the case. For example a loop with a `true` condition should never exit from looping. Then, all the statements after the loop becomes unreachable",
		"solution": "Remove the unreachable code",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_code",
		"message": "Unreachable code",
		"cause": "This error message is generated when a line of code cannot be reached in all the case. For example a loop with a `true` condition should never exit from looping. Then, all the statements after the loop becomes unreachable",
		"solution": "Remove the dead code",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_code",
		"message": "Dead code: The variable *name* will never be assigned",
		"cause": "This error message is generated when a line of code cannot be reached in all the case. For example a loop with a `true` condition should never exit from looping. Then, all the statements after the loop becomes unreachable",
		"solution": "Remove the dead code",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_code",
		"message": "Unreachable code",
		"cause": "This error message is generated when a line of code cannot be reached in all the case. For example a loop with a `true` condition should never exit from looping. Then, all the statements after the loop becomes unreachable",
		"solution": "Remove the dead code",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_code",
		"message": "Unreachable code. The last argument expression does not complete normally",
		"cause": "This error message is generated when the evaluation of the last argument causes a stop of the execution sequence that avoid to call the method/constructor for switch the argument is computed",
		"solution": "Remove the unreachable code",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_code",
		"message": "Unreachable code. The right argument expression does not complete normally",
		"cause": "This error message is generated when the evaluation of the right argument causes a stop of the execution sequence that avoid to call the operator for switch the argument is computed",
		"solution": "Remove the unreachable code",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.constant_condition",
		"message": "Constant condition is always *boolean-constant*",
		"cause": "The loop, if-then and switch statements may have a boolean condition that is evalued to `true` or `false`. In this case, the statement itself is superfluous. For example, in the case of a while-loop, if the condition is alwaus `true`, the loop will never exit. This issue message notifies you that a potentiel problem is detected because of the evaluation of an expression to `true` or `false`",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_case",
		"message": "Unreachable code: The case can never match. It is already handled by a previous condition",
		"cause": "You have specified a `case` that is already handled by another `case` before. It means that this `case` will never match because the previous one will do",
		"solution": "Remove `case`",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_instance_of",
		"message": "Unreachable code: The if condition can never match. It is already handled by a previous condition",
		"cause": "Inside a condition of `if` statement, you have specified multiple tests with `instanceof`. Since all the boolean conditions are evaluated from left to right, an `instanceof` test never matches because a left-most `instanceof` already matches the same scope of types",
		"solution": "Remove the unmatchable `instanceof`",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_catch_block",
		"message": "Unreachable code: The catch block can never match. It is already handled by a previous condition",
		"cause": "You have specified a `catch` that is already handled by another `catch` before. It means that this `catch` will never match because the previous one will do",
		"solution": "Remove `catch`",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.incomplete_cases_on_enum",
		"message": "The enum constant *name* needs a corresponding case label in this enum switch on *type-name*",
		"cause": "You have specified an enumerated value to a `switch` condition. The enumeration constant with the given *name* has not a corresponding `case` into the `switch`. It means that all the possible cases are not explicitly covered; It is preferrable they are all covered",
		"solution": "Add a `case` for the missed constant *name*",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.incomplete_cases_on_enum",
		"message": "The enum constants *list-of-names* need a corresponding case label in this enum switch on *type-name*",
		"cause": "You have specified an enumerated value to a `switch` condition. The enumeration constants with the given names have not corresponding `case` into the `switch`. It means that all the possible cases are not explicitly covered; It is preferrable they are all covered",
		"solution": "Add a `case` for each missed constant name",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.variable_name_shadowing",
		"message": "The field '*field-name*' in '*type-name*' is hidding the inherited field '*super-field-name*'",
		"cause": "You have declared a field with the name *field-name* into the current type; but an accessible field with the same name is also declared into a super-type. It means that the value of the field into the super-type will not be accessible directly from the current type",
		"solution": "Rename field *field-name*",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.variable_name_shadowing",
		"message": "Duplicate local variable *name*",
		"cause": "You have declared two different variables in the same scope but with exactly the same name. It is simply forbidden to hide local variables",
		"solution": "Rename one of the local variables",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.variable_name_disallowed",
		"message": "Invalid name '*name*'. You must not give to a field a name with reserved characters",
		"cause": "You have defined an name for a field that contains forbidden characters. The major forbidden character is &#x24;. It is not allowed to use it inside a name, even if it is allowed into the Java specification",
		"solution": "Rename your field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.variable_name_disallowed",
		"message": "Invalid name '*name*'. You must not give to an field the same name as a reserved keyword",
		"cause": "You have defined an name for a field that is equal to a reserved keyword",
		"solution": "Rename your field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.variable_name_disallowed",
		"message": "'*name*' is not a valid name",
		"cause": "This is the general error for notifying you that the name of an element is invalid. Most of the time, it is due to the use of a forbidden character into the *name*. The major forbidden character is &#x24;. It is not allowed to use it inside a name, even if it is allowed into the Java specification",
		"solution": "Rename the element",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.variable_name_discouraged",
		"message": "'*name*' is a discouraged name",
		"cause": "This is the general message for notifying you that the name of an element is discouraged. Most of the time, it is due to the fact it may cause ambiguity with SARL language keywords, e.g. `self`",
		"solution": "Rename the element",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.variable_name_discouraged",
		"message": "'self' is a discouraged name",
		"cause": "`self` is a name that is used in several other programming languages as a synonym of `this`. In order to avoid ambiguity, `self` is a discouraged name",
		"solution": "Rename the element",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.null_safe_feature_call_on_primitive",
		"message": "Cannot use null-safe feature call on primitive receiver",
		"cause": "Null-safe call of an method, e.g. `obj?.feature`, enables you to test the nullity of an object before calling a feature on  it. But, you have applied the null-safe call on a primitive type variable, i.e. `obj` is of primitive type. This is impossible because a primitive variable does not contain an object",
		"solution": "Remove the null-safe operator",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.null_safe_feature_call_on_primitive_valued_feature",
		"message": "Null-safe call of primitive-valued feature *feature-name*, default value *value* will be used",
		"cause": "This issue message is generated when a null-safe test is used for computing a primitive-type value. For example, the code `list?.isEmpty` explicitly replies the value of `isEmpty` if the `list` is not null. But when `list` is null, nothing indicates what could be the boolean value to give. SARL compiler assumes the default value for the primitive type, e.g. `false` for boolean.\nThis issue message is also generated when your are using an incomplete if-then statement, e.g. `var b = if (condition) true`. There is no `else`, so that the default value for the primitive type is assumed if the condition is evaluated to false",
		"solution": "Update your code to have a complete coverage of the cases",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.primitive_compared_to_null",
		"message": "The operator '*name*' is undefined for the argument types *type-name* and null",
		"cause": "This error message is generated when an (in)equality test operator, i.e., `==`, `===`, `!=` or `!==`, is invoked with the null literal as right operand, e.g. `x == null`, and the left operand being of primitive type. The problem is due to the usage of the keyword `null` that is not corresponding to a specific type. In this case, the SARL compiler cannot determine the best operator implementation",
		"solution": "Initialize to `null` a local variable with the expected type for the right operand, and use this local variable as right operand",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.primitive_compared_to_null",
		"message": "The operator '*name*' is undefined for the argument types null and *type-name*",
		"cause": "This error message is generated when an (in)equality test operator, i.e., `==`, `===`, `!=` or `!==`, is invoked with the null literal as left operand, e.g. `null == x`, and the right operand being of primitive type. The problem is due to the usage of the keyword `null` that is not corresponding to a specific type. In this case, the SARL compiler cannot determine the best operator implementation",
		"solution": "Initialize to `null` a local variable with the expected type for the left operand, and use this local variable as left operand",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.primitive_compared_to_null",
		"message": "The operator '?:' is undefined for arguments of type *type-name*",
		"cause": "This error message may be generated when your are using the elvis operator, with a primitive type value as left operand and the `null` literal as right operand, e.g. `x ?: null`. The problem is due to the usage of the keyword `null` that is not corresponding to a specific type. In this case, the SARL compiler cannot determine the best operator implementation",
		"solution": "Initialize to `null` a local variable with the expected type for the right operand, and use this local variable as right operand",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.equals_with_null",
		"message": "The operator '*name*' should be replaced by '*name*=' when null is one of the arguments",
		"cause": "This error message is generated when one of the (in)equality test operators `==` and `!=` is invoked with the null literal as left or right operand, e.g. `x == null` or `null == x`, and the other operand being of primitive type. These two test operators implement deep (in)equality tests. A better practice is to invoke the operator `===` or `!==`, which implement reference tests. Indeed, `null` value is a reference to nothing. It is better to compare a reference to another reference. And, the reference test operators are the most efficient for that",
		"solution": "Replace `==` by `===`, or `!=` by `!==`",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.not_instantiable",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unused_local_variable",
		"message": "The value of the local variable *name* is not used",
		"cause": "You have declared a local variable with the given *name*, but never use it somewhere",
		"solution": "Remove the variable declaration; or Use the variable",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_identifier",
		"message": "'*name*' is not a valid identifier",
		"cause": "This error is generated when you are using an identifier that is corresponding to a keyword of the Java programming language. Since the SARL compiler create Java source file, in order to make the generated files compilable, any variable with a name equals to a JAva keyword must be avoided",
		"solution": "Change the *name*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalidNumberFormat",
		"message": "Invalid number format: *explaination*",
		"cause": "A number literal has not a valid syntax",
		"solution": "Change the number literal to fullfil the number syntax",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.field_already_initialized",
		"message": "The final field *name* may already have been assigned",
		"cause": "You try to change the value of a final field after it was initialized. A value could be given to a final field only one time, i.e. its initialization",
		"solution": "Remove the expression that try to change the final field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_type",
		"message": "Undefined type for the formal parameter *name*",
		"cause": "A type specification is missed for the formal parameter with the given *name*",
		"solution": "Add a type to the formal parameter",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_type",
		"message": "Undefined type for the default value of the formal parameter *name*",
		"cause": "The type of the default for the formal parameter with the given *name* cannot be infered by the SARL compiler",
		"solution": "Change the default value's expression in order to make its type inferable",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_type",
		"message": "'void[]' is not a valid type",
		"cause": "This error is generated when you are specifying a type literal representing an array of `void`, e.g. `void[]` or `void[][]`. An array of void cannot be created in memory. It is therefore impossible to specify this type with a type literal",
		"solution": "Replace `void` by and appropriate type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.import_duplicate",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.import_unsued",
		"message": "The import '*name*' is never used",
		"cause": "This issue message is generated when an `import` statement does not provide features that are used into the current file",
		"solution": "Remove `import` statement",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.import_collision",
		"message": "The import '*package-1*.*name*' collides with the import '*package-2*.*name*'",
		"cause": "This error is generated when you define into the list of `import` two types with the same simple name. In this case, it is impossible to determine if an occurrence of *name* into the code refers to the type in the package *package-1* or in the package *package-2*",
		"solution": "Remove one of the `import`",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.import_conflict",
		"message": "The import '*package*.*name*' conflicts with a type defined in the same file",
		"cause": "You are importing a type with the given *name* into the given *package*. But, you have also defined a local type with the *name*. In this case, it is impossible to determine if an occurrence of *name* into the code refers to the local type or the imported type",
		"solution": "Rename the local type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.import_wildcard_deprecated",
		"message": "The use of wildcard imports is deprecated",
		"cause": "You are importing all the types that are defined into a package with `import pkg.*`. This instruction has two major drawbacks. Firstly, the really used types within the current are not explicit because of the wildcard. Second, the SARL compiler loads in memory too much type definitions for compiling the current file",
		"solution": "Replace the wildcard by the really used types",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.import_unresolved",
		"message": "The import *name* cannot be resolved",
		"cause": "The *name* that is provided after an `import` cannot be found",
		"solution": "Remove the `import` statement",
		"level": "c/error"
	},




	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.forbidden_reference",
		"message": "Forbidden annotation in a SARL program",
		"cause": "An annotation is used into the code. But this annotation is forbidden because it is reserved for internal usage, or it is not supported by the SARL compiler",
		"solution": "Remove the annotation",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.forbidden_reference",
		"message": "Forbidden annotation to the agent-oriented feature of type *type-name*",
		"cause": "An active annotation, i.e. an annotation that causes a specific generation of code by the SARL compiler, is attached to an agent-oriented type, e.g. `agent`, `behavior`, etc. But, it is forbidden to attached the active annotation to an agent-oriented type",
		"solution": "Remove the active annotation",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.forbidden_reference",
		"message": "Forbidden annotation to the object-oriented feature of type *type-name*",
		"cause": "An active annotation, i.e. an annotation that causes a specific generation of code by the SARL compiler, is attached to an object-oriented type, e.g. `class`, `interface`, etc. But, it is forbidden to attached the active annotation to an object-oriented type",
		"solution": "Remove the active annotation",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.forbidden_reference",
		"message": "Default value's expression cannot reference the not-pure operation: *name*",
		"cause": "This error message is generated when a reference to a non-pure function is detected into the expression of the default value for a formal parameter. Only pure functions could be used for building a default value expression in order to avoid unexpected side-effects",
		"solution": "Remove the reference to the not-pure function",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.forbidden_reference",
		"message": "Forbidden reference to not final field {0} from a constructor's default value expression",
		"cause": "This error message is generated when a reference to a not-final field is detected into the expression of the default value for a constructor's formal parameter. Only final fields could be used for building a default value expression of a constructor in order to avoid unexpected side-effects",
		"solution": "Remove the reference to the not final field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.forbidden_reference",
		"message": "Forbidden feature call: *feature*",
		"cause": "This error is generated when a forbidden feature call is detected. The forbidden features to call are: `System::exit` when it is inde an agent-oriented type, e.g. `agent`; with a name containing the forbidden character &#x24;.; or the feature is part of a private API and the caller is not part of the private API",
		"solution": "Remove the call",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.forbidden_reference",
		"message": "Access restriction: The type *name* is not accessible",
		"cause": "This error is generated when a reference to the type with the given *name* is detected, and the type is not visible/accessible",
		"solution": "Remove type reference",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.discouraged_reference",
		"message": "Discouraged feature call: *feature*. You should use the dedicated language keyword, or an agent's capacity in place of this feature call",
		"cause": "This error is generated when a discouraged feature call is detected. The features that outside the best practices are: `System::err`, `System::out`, `System::setErr`, `System::setOut`, `System::console`, `System::inheritedChannel`, `System::exit` (when called from an object-oriented type), with a named starting with \"InputOutput\" or \"Thread\". these different features are considered to be too low level to be used into a agent-oriented program",
		"solution": "Remove the call",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.raw_type",
		"message": "*name* is a raw type. References to generic type *name* should be parameterized",
		"cause": "You are referencing a generic type with the given *name* without specifying its generic type arguments",
		"solution": "Add the missed generic type arguments",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.raw_type",
		"message": "*expression* uses the raw type *name*. References to generic type *name* should be parameterized",
		"cause": "The given *expression* is referencing a generic type with the given *name* without specifying its generic type arguments",
		"solution": "Add the missed generic type arguments",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.type_bounds_missmatch",
		"message": "Invalid type: '*type*'. Only events can be used after the keyword 'on'",
		"cause": "The type that is specified after a `on` statement is not a SARL event, i.e. a sub-type of the type `Event`",
		"solution": "Replace *type* by an appropriate event type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.type_bounds_missmatch",
		"message": "Bounds mismatch: The type arguments *type-arguments* are not a valid substitute for the bounded type parameters *parameters* of the *feature-type* *feature-signature*",
		"cause": "The type that is specified after a `on` statement is not a SARL event, i.e. a sub-type of the type `Event`",
		"solution": "Replace *type* by an appropriate event type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.type_bounds_missmatch",
		"message": "Bounds mismatch: The type argument *type-argument* is not a valid substitute for the bounded type parameter *parameter* of the *feature-type* *feature-signature*",
		"cause": "The generic *type-argument* does not match the type bounding constraints of the corresponding generic type parameter of the specified feature. If the bounding constraint is `extends`, then the *type-argument* is not a sub-type of the one specified into the constraint. If the bounding constraint is `super`, then the *type-argument* is not a super-type of the one specified into the constraint",
		"solution": "Replace *type-argument* by an appropriate type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_type_parameter",
		"message": "Cannot perform type switch against type parameter *name*. Use its erasure Object instead since further generic type information will be erased at runtime",
		"cause": "You specify a generic type parameter as the type guard of a `case`, e.g. `T case 1`. Since there is no keept information about the generic types at runtime, the `case` statement cannot filter according to the type of the value. It is therefore recommended to use `Object` as the type guard",
		"solution": "Remove the type guard",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_type_parameter",
		"message": "Illegal class literal for the type parameter *name*",
		"cause": "You specify a generic type parameter as a type literal, e.g. `typeof(T)`. Since there is no keept information about the generic types at runtime, the `typeof` operator cannot reply the class at runtime",
		"solution": "Replace *name* by an appropriate type from the erasure of *name*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_type_parameter",
		"message": "Cannot perform instanceof check against type parameter *name*. Use its erasure *erasure-name* instead since further generic type information will be erased at runtime",
		"cause": "You specify a generic type parameter as the right operand of an `instanceof`, e.g. `x instanceof T`. Since there is no keept information about the generic types at runtime, the `instanceof` operator cannot proceed. The *erasure-name* is the base definition of *name* related to its bounds",
		"solution": "Replace *name* by *erasure-name*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.type_parameter_forward_reference",
		"message": "Illegal forward reference to type parameter *name*",
		"cause": "Since Java 5, forward references in type parameters are not allowed. Let define a list of generic type parameters `&p.lt;A, B extends C, C extends A&p.gt;`. In the previous example, `C` has a backward reference to `A`; and `B` has a forward reference to `C`. Then, `extends C` causes the generation of this error message. In other words, a local generic type parameters msut be declared before its usage into the bounds of another generic type parameter",
		"solution": "Change the order of the generic type parameters",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_type_parameter_bounds",
		"message": "The array type *type-name* cannot be used as a type parameter bound",
		"cause": "It is forbidden to use an array type into the generic type bounds, e.g. `&p.lt;? extends Integer[]&p.gt;`",
		"solution": "Replace the array into the generic bounds by an appropriate type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_type_parameter_bounds",
		"message": "The type parameter %name% cannot be used as a type parameter bound with additional bounds",
		"cause": "If you put a generic type paramater as bounds of another generic type parameter, it is forbidden to add more bounding constraints. For example, `&p.lt;A, B extends A&p.gt;` is valid. But, `&p.lt;A, B extends A & Cloneable&p.gt;` is invalid",
		"solution": "Remove the additional bounding constraint",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_type_arguments_on_type_literal",
		"message": "Invalid type argument. Type arguments cannot be applied to the type literal *name*",
		"cause": "You have specified a generic type argument into a type literal such as `typeof`; that is invalid. For example, `typeof(Collection)` is valid; but `typeof(Collection&p.lt;String&p.gt;)` is not",
		"solution": "Remove the generic type argument",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_type_arguments_on_type_literal",
		"message": "Invalid type arguments. Type arguments cannot be applied to the type literal *name*",
		"cause": "You have specified generic type arguments into a type literal such as `typeof`; that is invalid. For example, `typeof(Collection)` is valid; but `typeof(Collection&p.lt;String, Integer&p.gt;)` is not",
		"solution": "Remove the generic type arguments",
		"solution": "x",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.operation_without_parentheses",
		"message": "Method call without parentheses",
		"cause": "This error message is generated when a function is defined without a formal parameter, e.g. `def fct()`, and this function is called without parentheses, e.g. `fct`. In several programming standards, it is considered as a good practice to write the parentheses for each method call, even if there is no argument to pass to",
		"solution": "Add `()`",
		"level": "c/ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.operation_without_parentheses",
		"message": "Constructor call without parentheses",
		"cause": "This error message is generated when a constructor is defined without a formal parameter, e.g. `new ()`, and this constructor is called without parentheses, e.g. `this`. In several programming standards, it is considered as a good practice to write the parentheses for each constructor call, even if there is no argument to pass to",
		"solution": "Add `()`",
		"level": "c/ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.deprecated_member_reference",
		"message": "The method *func-prototype* from the type *container-name* is deprecated",
		"cause": "The method that you are calling is marked as deprecated directly, or one of its enclosing types is marked as deprecated",
		"solution": "Read the deprecation comment and update your code accordingly",
		"level": "d/org.eclipse.jdt.core.compiler.problem.deprecation/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.deprecated_member_reference",
		"message": "The field *name* is deprecated",
		"cause": "The field that you are accessor is marked as deprecated directly, or one of its enclosing types is marked as deprecated",
		"solution": "Read the deprecation comment and update your code accordingly",
		"level": "d/org.eclipse.jdt.core.compiler.problem.deprecation/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.deprecated_member_reference",
		"message": "The enum literal *name* is deprecated",
		"cause": "The enum literal that you are using is marked as deprecated directly, or one of its enclosing types is marked as deprecated",
		"solution": "Read the deprecation comment and update your code accordingly",
		"level": "d/org.eclipse.jdt.core.compiler.problem.deprecation/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.deprecated_member_reference",
		"message": "The constructor *name* is deprecated",
		"cause": "The constructor that you are calling is marked as deprecated directly, or one of its enclosing types is marked as deprecated",
		"solution": "Read the deprecation comment and update your code accordingly",
		"level": "d/org.eclipse.jdt.core.compiler.problem.deprecation/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.deprecated_member_reference",
		"message": "The type *name* is deprecated",
		"cause": "The type that you are referencing is marked as deprecated directly, or one of its enclosing types is marked as deprecated",
		"solution": "Read the deprecation comment and update your code accordingly",
		"level": "d/org.eclipse.jdt.core.compiler.problem.deprecation/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_type",
		"message": "Duplicate nested type *name*",
		"cause": "It is forbidden to define into an enclosing type two type declarations with the same given *name*",
		"solution": "Rename one of the inner types",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_type",
		"message": "Duplicate type *name*",
		"cause": "It is forbidden to define into a SARL file two type declarations with the same given *name*",
		"solution": "Rename one of the types",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_type",
		"message": "The type *name* is already defined",
		"cause": "It is forbidden to define into a SARL file two type declarations with the same given *name*",
		"solution": "Rename one of the types",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_type",
		"message": "The type *name* is already defined in file *filename*",
		"cause": "It is forbidden to define into a SARL file two type declarations with the same given *name*",
		"solution": "Rename one of the types",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_super_call",
		"message": "Cannot call super of an anonymous class from a lambda expression",
		"cause": "A closure/lambda expression is implemented by an anonymous class at the background, i.e. Java. You try to use the `super` statement that represents the instance viewed as the super-type of the associated anonymous class. However, it is forbidden to use `super` because the closure/lambda expression hides the background implementation, inclusing `super`",
		"solution": "Remove `super`",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unqualified_super_call",
		"message": "Unqualified super reference is not allowed in interface context",
		"cause": "You try to use the `super` statement from an interface. Because an interface has no associated instance of object and consequently not super-type instance, you cannot call `super`",
		"solution": "Remove `super`",
		"level": "c/error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.abstract_method_invocation",
		"message": "Cannot directly invoke the abstract method *func-prototype* of the type *name*",
		"cause": "The function with the given *func-prototype* is defined as non-abstract in the current type, and it is defined as `abstract` into the super-type. You try to call the super-type's method by using `super.function`. But, the super-type's function is `abstract`. Consequently, it cannot be invoked",
		"solution": "Remove the call to the super-type function",
		"level": "c/error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.refer_invalid_types",
		"message": "The field *field-name* has an illegal argument type",
		"cause": "One of the generic type arguments that is implicitly associated to the field *field-name* is specified as to be `void` or non-found into the classpath",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.refer_invalid_types",
		"message": "The method *func-prototype* from the type *type-name* has an illegal argument type",
		"cause": "One of the generic type arguments that is implicitly associated to the given method is specified as to be `void` or non-found into the classpath",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.refer_invalid_types",
		"message": "The constructor *constructor-prototype* has an argument of void type",
		"cause": "One of the generic type arguments that is implicitly associated to the given constructor is specified as to be `void` or non-found into the classpath",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.refer_invalid_types",
		"message": "The field *field-name* refers to the missing type *name*",
		"cause": "The given field is associated to a type that was not found into the classpath. The non-found type may be the raw type of the field, or one of the generic type parameters",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.refer_invalid_types",
		"message": "The method *func-prototype* from the type *type-name* refers to the missing type *name*",
		"cause": "The given method is associated to a type that was not found into the classpath",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.refer_invalid_types",
		"message": "The constructor *constructor-prototype* refers to the missing type *name*",
		"cause": "The given constructor is associated to a type that was not found into the classpath",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_multitype_part",
		"message": "The caught *type-name* is redundant",
		"cause": "You have specified multiple types, including *type-name*, into a multi-`catch` statement. The *type-name* is specified more than one time. You must not specify a type more than one time",
		"solution": "Remove one occurrence of *type-name*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_multitype_part",
		"message": "The *type-name-1* is already covered by the caught *type-name-2*",
		"cause": "You have specified multiple types, including *type-name-1* and *type-name-2*, into a multi-`catch` statement. The *type-name-1* is redundant because it is a sub-type of *type-name-2*",
		"solution": "Remove *type-name*-1",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_try_resource_type",
		"message": "The resource '*var-name*' of type *type-name* does not implement java.lang.AutoCloseable",
		"cause": "The try-with-resource statement enables you to automatically close an opened resource (file, socket, etc.). The given resource, named *var-named* must implement the interface `AutoCloseable` in order to be able to be automatically closed. This constraint comes from the Java underground API",
		"solution": "Change the resource by using one that is auto-closeable",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.diagnostics.Diagnostic.Linking",
		"message": "*name* cannot be resolved to a type",
		"cause": "You have specified a type *name* into your code, e.g. `typeof(MyType)`. But, no type declaration was found for *name* into the current compilation scope",
		"solution": "Replace *name* by an appropriate type name; or Add the type *name* into the compilation scope, by using an `import` statement for example",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.diagnostics.Diagnostic.Linking",
		"message": "The method *func-prototype* is undefined",
		"cause": "You have specified a function call to *func-prototype* into your code, e.g. `myfct()`. But, no method declaration was found for *func-prototype* into the current compilation scope",
		"solution": "Replace *func-prototype* by an appropriate function call; or Add the method into the compilation scope, by using an `import` statement for example",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.diagnostics.Diagnostic.Linking",
		"message": "The method or field *name* is undefined",
		"cause": "You have specified a function call to *name*, or a reference to the field *name*, into your code. But, neither a method declaration nor a field declaration was found into the current compilation scope",
		"solution": "Replace *name* by an appropriate function call or field reference; or Add the method/field into the compilation scope, by using an `import` statement for example",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.diagnostics.Diagnostic.Linking",
		"message": "The method *func-prototype* is undefined for the type *type-name*",
		"cause": "You have specified a function call to *func-prototype* into your code, e.g. `myfct()`. But, no method declaration was found for *func-prototype* into the current compilation scope",
		"solution": "Replace *func-prototype* by an appropriate function call; or Add the method into the compilation scope, by using an `import` statement for example",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.diagnostics.Diagnostic.Linking",
		"message": "The method or field *name* is undefined for the type *type-name*",
		"cause": "You have specified a function call to *name*, or a reference to the field *name*, into your code. But, neither a method declaration nor a field declaration was found into the current compilation scope",
		"solution": "Replace *name* by an appropriate function call or field reference; or Add the method/field into the compilation scope, by using an `import` statement for example",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.diagnostics.Diagnostic.Linking",
		"message": "Couldn't resolve reference to *name*",
		"cause": "You have written a reference to a feature that cannot be found from the current compilation scope. Since, it cannot be found, SARL compiler cannot determine the concrete type of the feature",
		"solution": "Replace *name* by an appropriate feature; or Add the feature into the compilation scope, by using an `import` statement for example",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.builder.copyJavaProblems",
		"message": "*any-message*",
		"cause": "Sometime, the Java code that is generated by the SARL compiler may contain compilation errors from the Java compiler point of view. This error code enables the SARL validator to forward the errors that were found into the Java code to be automatically attached to the SARL statement that is the source of the failing Java code",
		"solution": "Contact the SARL development team",
		"level": "c/error"
	},
	{
		"code": "io.sarl.lang.parser.SyntaxIssueCodes.used_reserved_keyword",
		"message": "'*name*' is a reserved keyword which is not allowed as identifier. Please choose another word or alternatively confuse your co-workers by escaping it like this: *simple-solution*",
		"cause": "You defined the name of a feature by using a *name* that is equal to a SARL keyword. As in all programming languages, it is forbidden to use a language keyword as identifier. This error message problem to you a *simple-solution*",
		"solution": "Apply *name* to *simple-solution* or to another name that is not a SARL keyword",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.parser.SyntaxIssueCodes.used_reserved_keyword",
		"message": "'*name*' is a reserved keyword which is not allowed as identifier. Please choose another word",
		"cause": "You defined the name of a feature by using a *name* that is equal to a SARL keyword. As in all programming languages, it is forbidden to use a language keyword as identifier",
		"solution": "Change *name* to another identifier that is not a SARL keyword",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.diagnostics.Diagnostic.Syntax",
		"message": "*any-message*",
		"cause": "This error is generated when your SARL code has an improper syntax, and cannot be parsed by the SARL compiler. The error message provides the detail of the invalid syntax",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.diagnostics.Diagnostic.Syntax&dot;Range",
		"message": "*any-message*",
		"cause": "This error is generated when your SARL code has an improper syntax, and cannot be parsed by the SARL compiler. The error message provides the detail of the invalid syntax and the position into your source code that is under failure",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.generic_type_name_shadowing",
		"message": "The generic type parameter '*name*' is hiding the generic type parameter of '*type-name*'",
		"cause": "This error is generated when you declared a generic type parameter for an action that has the same name as another generic type parameter that is declared into the enclosing type (class, or interface)",
		"solution": "Change the *name*",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.parameter_default_value_redefinition",
		"message": "Redundant definition of the default value for the formal parameter *name*",
		"cause": "This warning message is generated when you declared a default value for a formal parameter that has already a default value declared into one of the super types. It is not necessary to redefine the same default value for the formal parameter",
		"solution": "Remove the redundant declaration fo the default value",
		"level": "c/warning"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.illegal_parameter_default_value_redefinition",
		"message": "Illegal redefinition of the default value for the formal parameter *name*. Inherited value is: *original value*. While the current value is: *redefined value*.",
		"cause": "This error message is generated when you declared a default value for a formal parameter that is different from the corresponding default value that was declared into the super types. You cannot change the default value of a formal parameter because it may cause unexpected side-effects for the callers of the function",
		"solution": "Remove the redundant declaration fo the default value",
		"level": "error"
	},
	{
		"code": "io.sarl.lang.validation.IssueCodes.potential_memory_sharing_outside_agent_control",
		"message": "Potential problem of data sharing outside the control of the agent. The field '**name**' is declared with the static modifier. It enables the code to change the field value outside a direct control of the agent; that is breaking partly the agent autonomy principle",
		"cause": "This warning message is generated when you declared a field with the `static` modifier into an agent or on of its components. Basically, a static field is defined outside an instance of agent or component. In other words, the static field could be used for sharing data between the components of the agents, and between the agents themselves. This method of data sharing is breaking the agent autonomy principle. It should be used only for sharing constant data between the agents",
		"solution": "Remove the `static` modifier",
		"level": "c/warning"
	}
]

